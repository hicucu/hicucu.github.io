{"pages":[{"title":"about","text":"Contact Github:https://github.com/hicucu Email: hicucu@gmail.com","link":"/about/index.html"},{"title":"DOM","text":"DOMDocument Object Model 텍스트 파일로 만들어져 있는 웹 문서를 브라우저에 렌더링하려면 웹 문서를 브라우저가 이해할 수 있는 구조로 메모리에 올려야 한다.브라우저의 렌더링 엔진은 웹 문서를 로드한 후, 파싱하여 웹 문서를 브라우저가 이해할 수 있는 구조로 구성하여 메모리에 적재하는데 이를 DOM이라고 한다.즉 모든 요소와 요소의 어트리부트, 텍스트를 각각의 객체로 만들고 이들 객체를 부자 관계를 표현할 수 있는 트리 구조로 구성한 것이 DOM이다.이 DOM은 자바스크립트를 통해 동적으로 변경할 수 있으며 변경된 DOM은 렌더링에 반영된다. DOM은 HTML, ECMAScript에서 정의한 표준이 아닌 별개의 W3C의 공식 표준이며 플랫폼/프로그래밍 언어 중립적이다. DOM은 두가지 기능을 담당한다. HTML 문서에 대한 모델 구성: 브라우저는 HTML 문서를 로드한 후 해당 문서에 대한 모델을 메모리에 생성, 이때 모델은 객체의 트리로 구성되는데 이것을 DOM tree라고 한다. HTML 문서 내의 각 요소에 접근 및 수정: DOM은 모델 내의 각 객체에 접근하고 수정할 수 있는 프로퍼티와 메소드를 제공, DOM이 수정되면 브라우저를 통해 화면이 변경된다.","link":"/Javascript/DOM.html"},{"title":"Constructor Function","text":"생성자 함수객체를 리터럴을 이용하여 생성하면 직관적이고 간편하다.그러나 객체 리터럴에 의한 객체 생성 방식은 단 하나의 객체만을 생성한다.따라서 동일한 프로퍼티를 갖는 객체를 여러 개 생성해야 하는 경우, 매번 같은 프로퍼티를 기술해야하는 비효율이 발생한다. 생성자 함수에 의한 객체 생성 방식생성자 함수에 의한 객체 생성은 객체를 생성하기 위한 템플릿처럼 생성자 함수를 이용하여 동일한 프로퍼티 구조의 객체를 간편하게 여러 개 생성할 수 있다. 생성자 함수는 특별한 형식이 정해진 것이 아니라 일반 함수와 동일한 방법으로 함수를 정의하고 new 연산자를 함께 호출하면 생성자 함수로 동작한다. 만약 생성자 함수를 호출하지 않으면 생성자 함수가 아니라 일반 함수로 동작한다. 내부 메소드 [[Call]], [[Construcor]]함수 선언문 또는 함수 표현식으로 정의한 함수는 일반적인 함수로 호출할 수도 있고 생성자 함수로 호출할 수도 있다. 생성자 함수로 호출한다는 것은 new 연산자와 함께 호출하여 객체를 생성한다는 것이다. 내부 메소드 [[Call]]이 구현되어 있는 객체를 callable이라 하고, 내부 메소드인 [[Constructor]]가 구현되어 잇는 객체를 constructor, 구현되어 있지 않은 객체를 non-costructor라고 부른다. callable은 호출할 수 있다는 것으로 함수를 말한다. constructor는 생성자 함수로서 호출할 수 있는 객체를 의미한다. 함수가 일반 함수로 호출되면 내부 메소드 [[Call]]이 호출되는 것이고 new 연산자(또는 super)와 함께 생성자 함수로서 호출된다면 내부 메소드 [[Constructor]]가 호출된다. 호출 할 수 없는 객체는 함수 객체가 아니므로 모든 함수 객체는 반드시 callable이어야 한다.따라서 모든 함수 객체는 [[Call]]이 구현되어 있어 호출 할 수 있다. 하지만 모든 함수 객체가 [[Constructor]]를 구현하지는 않는다.즉 함수 객체는 constructor일 수도 있고 non-constructor일 수도 있다. 모든 함수 객체는 호출 할 수 있지만 생성자 함수로서 호출할 수 있는 것은 아니다. constructor와 non-constructor일반 함수로 정의된 함수만이 constructor이다.함수의 종류가 Arrow, Method인 함수는 non-constructor가 된다. 함수가 일반적인 함수로서 호출되면 함수 객체의 내부 메소드 [[Call]]가 호출되고 new 연산자 또는 super 연산자와 함께 생성자 함수로서 호출되면 내부 메소드 [[Constructor]]가 호출된다. ES6의 메소드 축약 표현만을 메소드 정의로 인정한다. 생성자 함수의 동작 방식생성자 함수의 역할은 프로퍼티 구조가 동일한 인스턴스를 생성하기 위한 템플릿(클래스)으로서 동작하여 인스턴스를 생성하는 것과 생성된 인스턴스의 프로퍼티 값을 초기화하는 것이다. 빈 객체 생성과 this 바인딩 생성자 함수 내부의 코드가 실행되기 전에 먼저 빈 객체가 암묵적으로 생성된다. 그리고 생성된 빈 객체는 this에 바인딩된다. 생성된 빈 객체를 가리키는 this를 사용하여 프로퍼티나 메소드를 추가한다. 그리고 프로퍼티에 인수로 전달받은 초기값을 할당하여 초기화하거나 고정값을 할당한다. 이 처리는 개발자가 기술한다. 생성자 함수 내부의 모든 처리가 끝나면 암묵적으로 this를 반환한다.만약 명시적으로 return문을 구현하면 this가 아닌 명시적으로 표현한 객체가 반환된다. 생성자 함수 내부에서 명시적으로 this가 아닌 다른 값을 반환하는 것은 생성자 함수의 기본 동작을 훼손한다. 따라서 생성자 함수 내부에서 return 문을 반드시 생략해야 한다.","link":"/Javascript/Constructor-Function.html"},{"title":"Function Definition","text":"Function프로그래밍 언어의 ㅎㅁ수는 일련의 과정을 문(statement)들로 구현하고 코드 블록으로 감싸서 하나의 실행 단위로 정의한 것이이다. 이 때 입력을 전달받는 변수를 매개변수(parameter), 입력을 인수(argument), 출력을 반환값(return)이라고 한다. 함수는 여러 개가 존재 할 수 있어 특정 함수를 구별하기 위하여 함수명이라는 식별자를 사용한다. 함수 정의Javascript에서 함수를 정의하는 방법은 4가지가 있다. 함수 선언문(Function Declaration/Function Statement) 함수 표현식(Function Expression) Function 생성자 함수(Function Constructor) 화살표 함수(Arrow Function): ES6 모든 방식은 함수를 정의한다는 결과적인 면에서 동일하나 각각 차이가 존재한다. 함수 선언문과 함수 표현식함수 선언문은 문(Statement)이다.함수 선언문은 표현식이 나닌 문으로 실행되어 객체를 생성한다. 이 때 함수 객체를 할당할 변수가 필요하다.함수 객체를 변수에 할당하지 않으면 생성된 함수 객체를 사용할 수 없고 아무도 참조하지 않기 때문에 메모리에서 해제된다. 하지만 함수선언문은 함수명을 생략할 수 없고 자바스크립트 엔진은 암묵적으로 함수선언문의 함수명과 동일한 변수를 만들어 생성된 함수를 할당한다. 즉, 함수는 함수명으로 호출하는 것이 아니라 자바스크립트 엔진이 암묵적으로 함수명과 동일하게 생성한 변수를 호출하는 것이다. 이 암묵적인 동작을 사용자가 직접 하면 함수 표현식으로 자바스크립트 엔진은 함수 선언문을 함수 표현식으로 변환하여 함수 객체를 생성한다 할 수 있다. 함수 표현식은 식으로 함수를 값으로 평가한다.그렇기 때문에 변수에 함수를 할당한다. 함수 표현식은 함수 선언문과 같이 암묵적으로 함수명을 가지고 변수를 만드는 것이 아니라 사용자가 변수에 함수를 할당하는 형태이기 때문에 함수명을 생략하여 익명함수 형탵를 갖게 할 수 있다. 결론적으로 자바스크립트엔진에 의하여 함수 선언문은 암묵적으로 선언된 변수에 할당이 되어 함수 표현식과 같이 동작하는 것 처럼 보인다.하지만 이 암묵적 동작으로 인하여 두 개의 방식은 차이가 발생한다. 함수 호이스팅함수 표현식은 변수에 함수를 할당하는 형태이다.그렇기 때문에 자바스크립트에 의하여 변수 호이스팅이 발생한다. 자바스크립트 엔진은 실행시점에서 변수 호이스팅을 한다.그렇기 때문에 함수 표현식을 할당한 변수도 호이스팅이 발생한다. 표현식은 할당문이 실행되는 시점에서 값으로 평가되어진다.그렇기 때문에 함수 표현식이 평가되는 시점 이전에 함수 표현식이 할당된 변수를 참조하면 undefined가 발생하며 함수를 호출하면 에러가 발생한다.(var로 선언한 경우) 그러나 함수 선언문은 암묵적으로 생성된 변수에 할당이 되면서 변수만 호이스팅이 되는 것이 아니라 호이스팅 시점에서 함수 자체가 평가되어 변수에 할당이 된다. 즉, 함수 선언문 이전에 함수를 사용하여도 정상적으로 동작한다. 이는 함수 호출 전에 함수를 선언해야 한다는 규칙을 무시하여도 동작하는 문제를 발생시켜 코드의 구조를 엉성하게 만들 수 있다. Function 생성자 함수빌트인 함수인 Function 생성자 함수는 매개변수 목록과 함수 몸체를 문자열로 전달받는다.new 연산자와 함께 호출하며 생성된 함수 객체를 반환한다. 하지만 함수 생성자 함수를 이용하여 생성한 함수는 렉시컬 스코프를 만들지 않고 전역 함수인 거처럼 스코프를 생성한다. 그렇기 때문에 클로저도 생성하지 않는다. 결론적으로 unction 생성자 함수로 함수를 생성하는 방식은 일반적이지 않으며 바람직하지 않다. 화살표 함수기존 함수 선언문이나 함수 표현식으로 만든 함수와는 다르게 this 바인딩 방식이 다르며, prototype 프로퍼티가 없고, arguments 객체를 생성하지 않는다. 화살표함수는 항상 익명함수로 정의하기 때문에 보통 고차함수에 사용된다.","link":"/Javascript/Function-Definition.html"},{"title":"Javascript Datatype","text":"동적 타입자바스크립트는 동적 타입의 언어이다.즉 변수의 타입을 미리 선언할 필요가 없다.타입은 프로그램이 처리되는 과정에서 같은 변수에 여러 타입의 값을 넣을 수 있다. 테이터 타입ECMAScript 표준에서 자바스크립트의 자료형을 7가지로 정의한다. 원시타입 Boolean Null Undefined Number String Symbol Object 원시타입Object를 제외한 모든 타입은 immutable이다. Boolean논리적 요소를 나타낸다.true, false 두 가지 값을 가질 수 있다. Nullnull만 존재한다.어떤 값이 의도적으로 비어있음을 의미한다. Undefinedundefined값을 가진다.값을 할당하지 않은 변수. Number64비트 부동소수점만 존재한다.정수역시 64비트 부동소수점으로 표현한다.+Infinity, -Infinity, NaN 세가지 상징적인 값도 존재한다.0은 +0, -0 두가지로 표현이가능하지만 둘을 ===연산으로 비교시 true다.하지만 어떤 수를 -0으로 나누면 -Infinity, +0으로 나누면 +Infinity가 된다. String텍스트 데이터를 나타내는데 사용한다.16비트 부호없는 정수 값 요소들의 집합이다.유사배열로 각 문자들은 index를 가지고 있다. Symbol 타입유일하고 변경 불가능한 기본값key값으로 사용할 수 있다. Object원시값을 제외한 모든 값은 객체이다.","link":"/Javascript/Javascript-Datatype.html"},{"title":"Scope, Lexical Scope","text":"스코프변수는 자신이 선언된 위치에 의해 자신이 유효한 범위가 생긴다.이것은 다른 코드가 변수 자신을 참조할 수 있는 범위가 된다. 함수의 매개변수나 함수 내부에서 선언한 변수는 함수 내부에서만 참조할 수 있다. 함수 내부와 외부에 동일한 이름의 변수가 있다고 하여도 이 두 변수는 식별자의 이름만 같은 다른 변수이다. 즉, 스코프가 다른 별개의 변수이다. 만약 스코프의 개념이 없으면 프로그램 전체에서 각 변수의 명은 하나씩 존재할 수 밖에 없다. 스코프의 종류코드는 전역(global)과 지역(local)으로 구분할 수 있다.이 때 변수는 자신이 선언된 위치에 의해 자신이 유효한 범위인 스코프가 결정된다.즉, 전역에서 선언된 변수는 전역 스코프를 갖는 전역 변수이고, 지역에서 선언된 변수는 지역 스코프를 갖는 지역 변수이다. 전역 스코프전역 변수는 전역 스코프를 갖는 변수이다.전역 변수는 어디서든 참조할 수 있다. 즉, 전역 변수는 전역 스코프에서 유효하다. 지역 스코프지역이란 함수 몸체 내부를 의미한다.지역은 지역 스코프를 만든다. 지역 변수를는 지역 스코프를 갖는 변수이다. 즉, 지역 변수는 자신의 지역 스코프와 하위 지역 스코프에서 유효하다. 스코프 체인함수는 중첩될 수 있으므로 지역 스코프도 중첩될 수 있다.스코프는 함수의 중첩에 의해 계측적 구조를 갖는다. 중첩 함수의 지역 스코프는 중첩 함수를 포함하는 외부 함수의 지역 스코프와 계층적 구조를 갖는다.이 때 외부 함수의 지역 스코프를 중첩 함수의 상위 스코프라고 한다. 이렇게 스코프가 계층적으로 연결되는 것을 스코프 체인이라고 부른다. 변수를 참조할 때, 자바스크립트 엔진은 스코프 체인을 통해 변수를 참조하는 코드의 스코프에서 시작하여 상위 스코프 방향으로 이동하며 선언된 변수를 검색한다. 즉, 식별자를 검색하는 규칙이라고 표현할 수 있다. 렉시컬 스코프스코프의 결정은 두 가지 패턴이 존재한다. 함수를 어디서 호출했는가 함수를 어디서 정의 했는가 어디서 호출했는지에 따라 결정되는 방식을 동적 스코프라고 한다. 어디서 정의 했는가에 따라 결정되는 방식을 렉시컬 스코프 또는 정적 스코프라고 한다. 동적 스코프 방식은 함수를 호출하는 위치에 따라 스코프가 변화하지만 렉시컬 스코프는 어디서 호출하던지 정의된 위치에 따라 스코프가 고정된다. 자바스크립트는 렉시컬 스코프를 따르므로 함수를 어디서 호출했는지가 아닌 어디서 정의 했는지에 따라 상위 스코프가 결정된다. 이것은 모든 함수 정의가 평가되어 객체를 생성할 때, 자신이 정의된 스코프를 기억하는 것이다.그리고 함수가 호출되면 자신이 기억하고 있는 자신이 정의된 스코프를 상위 스코프로 사용한다. 이것은 결국 클로저가 되는 것이다. 클로저란 함수와 그 함수가 선언된 렉시컬 환경과의 조합이다. 자바스크립트의 모든 함수는 자신의 상위 스코프를 기억한다. 모든 함수가 기억하는 상위 스코프는 함수를 어디서 호출하던지 상관없이 유지된다.따라서 함수를 어디서 호출하던지 상관없이 함수는 언제나 자신이 기억하는 상위 스코프의 변수를 참조할 수 있으며 스코프의 변수값을 변경할 수 있다. 즉, 자신이 평가될 때 자신이 정의된 시점의 상위스코프를 저장하고 함수 자신이 존재하는한 이 저장된 상위 스코프는 유지가 된다. 이론적으론 자바스크립트의 모든 함수는 상위 스코프를 기억하므로 모든 함수는 클로저이다.그러나 일반적으로 모든 함수를 클로저라고 하지 않는다. 클로저는 중첩 함수가 상위 스코프의 식별자를 참조하고 있고 중첩 함수가 외부 함수보다 더 오래 유지되는 경우에 한정한다.","link":"/Javascript/Scope-Lexical-Scope.html"},{"title":"Primitive type vs Object type","text":"Primitive type과 Object typeJavascript의 데이터 타입은 7가지이다.이 중 Object를 제외한 6가지는 원시타입(primitive type)이다.데이터 타입을 원시타입과 객체타입으로 나누는 가장 큰 차이는 세가지가 있다. 원시타입의 값은 immutable로 변경이 불가능하다. 원시 값을 변수에 할당하면 변수에는 실제 값이 저장된다. 하지만 객체를 변수에 할당하면 변수에는 참조 값이 저장된다. 원시 값을 갖는 변수를 다른 변수에 할당하면 값이 복사되어 전달된다. 하지만 객체를 가리키는 변수를 다른 변수에 할당하면 원본의 참조 값이 복사되어 전달된다. 원시값immutable한번 생성된 원시 값은 read only이다.즉 변경이 불가능하다.여기서 변경이 불가능 하다는 것은 변수가 아니라 값 자체이다.변수의 값을 바꾸는 것은 재할당이다.변수는 새로운 값을 재할당하여 값을 바꿀 수 있다. 그렇기에 변수이다.재할당을 할 수 없는 것은 상수이지만 상수역시 변수다.원시값의 변경 불가능은 상수가 갖는 재할당을 못한다는 것과는 다른 것이다. 원시 값을 갖는 변수에 재할당을 하면 값이 바뀌는 것이 아니라 변수가 참조하고 있던 메모리 공간의 주소가 바뀌는 것이다. 즉, 이전의 값은 변경을 할 수 없는 변경 불가능이기 때문에 새로운 메모리 공간에 새로운 값을 저장하고 그 새로운 공간의 주소를 변수가 참조하는 것이다. 상수는 이 새로운 공간에 대한 참조를 막아 한 번만 참조를 하고 다시는 참조하지 못하도록 재할당을 막는 것이다. 원시타입을 갖는 변수에 값을 바꾼다는 것은 원시타입의 값이 바뀌는 것이 아니라 변수가 다른 값을 갖는 공간을 참조하는 것이다. String타입역시 원시값으로 변경 불가능이다.그러나 유사배열인 String타입의 변수에 index를 이용하여 값을 변경시키려고 하면 오류가 발생하지 않는다.그러나 String은 변경 불가능으로 다시 원래의 변수의 값을 확인하면 바뀌지 않는다. Pass by Value or Call by Value어떠한 변수에 원시값을 할당한다.그리고 또 다른 변수에 앞의 변수를 할당한다.그렇면 두 변수의 값은 동일하다.그러나 하나의 변수에 다른 값을 다시 할당한다고 해서 다른 변수의 값이 바뀌지 않는다. 이는 두 변수가 값은 같지만 서로 다른 메모리 공간을 바인딩 하였기 때문이다. 두번째 변수에 첫번째 변수를 할당하면 값은 갖지만 그것은 할당되는 변수의 값을 복사하여 할당받는 할당한 것이기 때문이다. 이것은 함수나 메서드의 파라미터에 값을 전달할 때 역시 마찬가지다 그렇기 때문에 파라미터로 받은 값을 변경한다고 하여도 함수를 호출한 곳의 아규먼트의 값은 바뀌지 않는다. 이것을 값에 의한 전달 혹은 값에 의한 호출이라고 한다. 객체객체는 프로퍼티를 갖는데 이 프로퍼티의 개수가 정해져 있지 않고 동적으로 추가하고 삭제할 수 있다.그렇기 때문에 확보해야 할 공간의 크기를 미리 정할 수 없다. 그렇기 때문에 원시값과는 다른 동작을 한다. mutable원시값을 변수에 할당하면 변수는 원시값이 저장되어 있는 메모리 공간에 바인딩된다. 그리고 변경 불가능하기 때문에 새로운 값을 할당하면 변수는 새로운 메모리 공간에 바인딩된다. 하지만 객체는 객체가 실제 저장되어 있는 공간에 변수가 바인딩되는 것이 아니라 실제 저장되어 있는 메모리 공간의 주소를 가지고 있는 메모리 공간에 바인딩된다. 즉, 객체가 가지고 있는 프로퍼티의 값을 변경하면 객체변수의 메모리 공간이 원시타입처럼 바뀌는 것이 아니라 값이 실제 저장되어 있는 공간에서 해당 프로퍼티가 변경이 되는 것이다. 그렇기 때문에 객체타입의 변수는 여전히 같은 공간에 바인딩 되어 있지만 값이 변하는 것이다. 즉 실제 값이 저장되어 있는 곳이 바뀌더라도 여전히 객체는 주소를 가지고 있고 그 주소는 변하지 않기 때문에 메모리 공간의 교체 없이 값을 바꿀 수 있다. 얇은 복사와 깊은 복사원시타입의 값은 복사를 하면 값 자체가 복사가 되기 때문에 원본 값을 바꾼다고 하여도 복사된 값이 바뀌지 않는다. 하지만 객체는 객체 자체가 복사되는 것이 아니라 그 객체가 존재하는 메모리 공간의 주소가 값으로 복사되기 때문에 원본과 복사본 모두 동일한 메모리 공간의 주소를 갖고 그 주소의 값을 이용하기 때문에 둘 중하나의 객체의 프로퍼티를 수정하면 두 변수의 값 모두 변경된다. 이런 복사를 얇은 복사라고 하며 두 변수가 서로 독립적인 객체를 갖도록 하는 것 깊은 복사이다. Pass by reference or Call by reference객체 타입의 변수를 다른 변수에 할당하면 두 변수는 동일한 값을 갖는 얇은 복사가 일어난다. 이것은 원본 변수가 가지고 있는 것이 객체가 아니라 그 객체의 주소이기 때문에 주소가 복사되어 결국 두 변수 모두 같은 주소를 저장하고 있기 때문에 객체 자체는 같은 객체를 공유하는 것이기 때문이다. 이처럼 객체는 값이 아니라 값을 가지고 있는 메모리 공간의 주소를 참조하는 형식이며 이 참조값이 주소가 전달되는 것이다. 그래서 파라미터로 객체를 주면 해당 객체의 주소가 복사되고 그 객체의 프로퍼티를 바꾼다 하여도 주소는 바꾸지 않고 참조되고 있는 객체의 값은 양쪽 모두가 변경된다. 이렇게 참조에 의해 값이 전달되는 것을 참조의 의한 전달이라고 한다. 사실 엄밀히 말하면 주소값도 값으로 Pass by Value이지만 그냥 Pass by reference라 하자","link":"/Javascript/Primitive-type-vs-Object-type.html"},{"title":"웹 브라우저는 어떻게 동작하는가?","text":"환경대부분의 프로그래밍 언어는 운영 체제 위에서 실행되지만 웹 애플리케이션의 자바스크립트는 브라우저에서 HTML, CSS와 함께 실행된다. 웹 브라우저는 어떻게 동작하는가?브라우저의 핵심 기능은 사용자가 참조하고자 한느 웹 페이지를 서버에 Request하고 서버의 Response를 받아 브라우저에 표시하는 것이다. 브라우저는 서버로부터 HTML, CSS, 자바스크립트, 이미지 파일 등을 응답 받는다.HTML, CSS 파일은 렌더링 엔진의 HTML 파서와 CSS 파서에 의해 파싱되어 DOM, CSSOM 트리로 변환되고 렌더 트리로 결합된다. 이렇게 생성된 렌더 트리를 기반으로 브라우저는 웹 페이지를 보여준다. HTML, CSS는 렌더링 엔진에 의해 처리되지만 자바스크립트는 렌더링 엔진이 아닌 자바스크립트 엔진에 의해 처리된다. HTML파서는 script 태그를 만나면 DOM 생성 프로세스를 중지하고 자바스크립트 엔진으로 제어 권한을 넘겨 자바스크립트 코드를 실행하게 한다. 자바스크립트 엔진은 제어 권한을 받아 script 태그 내 자바스크립트 코드 또는 script 태그의 src 속성에 정의된 자바스크립트 파일을 로드하고 파싱하여 실행한다. 대부분의 모던 브라우저에서 사용되는 인터프리터는 전통적인 컴파일 언어처럼 명시적인 컴파일 단계를 거치지는 않지만 일부 소스 코드를 컴파일하여 실행한다. 이를 통하여 인터프리터 언어의 장점인 동적 기능 지원을 유지하며 실행 속도가 느리다는 단점을 극복한다. 자바스크립트의 실행이 완료되면 다시 HTML 파서로 제어 권한이 넘어가며 브라우저는 중지했던 지점부터 DOM 생성을 재개한다. 즉, 브라우저의 HTML, CSS, 자바스크립트의 처리는 동기(Synchronous)적으로 처리하며 이는 script의 태그 위치에 따라 블로킹이 발생할 수 있음을 의미한다. 그렇기 때문에 script 태그의 위치는 중요하다. 자바스크립트가 실행될 때에는 이미 HTML 파서가 HTML 요소를 모두 파싱하여 DOM 객체를 생성한 이후라면 큰 문제가 없지만 그 이전이라면 DOM이 완성되지 않은 상태에서 자바스크립트가 DOM을 조작하는 에러가 발생할 수 있다.","link":"/Javascript/environment.html"},{"title":"Literal과 Expression","text":"리터럴소스 코드 안에서 직접 만들어 낸 고정된 값을 말한다.정확히는 값이 될 것이다.리터럴은 자바스크립트 엔진에 의해 해석되어 값으로 평가된다. 그렇기 때문에 결국 값이 될 것이므로 값이라 한다. 리터럴 표기법리터럴은 사람이 이해할 수 있는 표기법으로 값의 생성을 자바스크립트 엔진에게 명령하는 것이다. 자바스크립트 엔진은 리터럴 표기법으로 작성된 코드 = 리터럴을 만나면 코드가 실행되는 시점에서 코드 = 리터럴을 해석하고 그에 상응하는 값을 생성한다.즉 리터럴은 실행시점에서 값이다. 리터럴은 그 자체로 값이며 표현식이다.또한 표현식의 일부로서 다른 값을 생성하는데 사용되기도 한다. 리터럴 표기법을 사용하면 다양한 타입의 값을 생성할 수 있다. 표현식(expression)표현식은 하나의 값으로 평가될 수 있는 문이다.리터럴, 식별자, 연산자, 함수 호출 등의 조합을 말하며 값으로 평가될 수 있다.즉, 표현식은 값과 동치로 값이 위치할 수 있는 자리에는 표현식도 위치할 수 있다. 10 + 20이라는 표현식을 리터럴 10과 20, 연산자 +로 구성된 표현식이다.그리고 이 표현식은 30이라는 값으로 평가되며 두개는 동일하다. 문(statement)과 표현식(expression)문은 하나 이상의 표현식과 키워드의 조합으로 구성된 자바스크립트 엔진에게 내리는 명령이다. 자바스크립트의 모든 코드는 문 또는 표현식이다.표현식의 역할은 값을 생성하는 것이다. 문의 역할은 표현식으로 생성한 값을 사용해 자바스크립트 엔진에게 명령을 내리는 것이다. 표현식인 문과 표현식이 아닌 문표현식인 문과 표현식이 아닌 문을 구별하기 위한 가장 간단하고 명료한 방법은 변수에 할당하는 것이다.표현식인 문은 값으로 평가되기 때문에 변수에 할당할 수 있다.","link":"/Javascript/javascript-Literal.html"},{"title":"this","text":"thisthis는 객체 자신의 프로퍼티나 메소드를 참조하기 위한 자기 참조 변수(Self-referencing variable)이다. 함수 호출 방식과 this 바인딩this에 바인딩될 객체는 함수의 호출방식, 즉 함수가 어떻게 호출되었는지에 따라 동적으로 결정된다. 함수를 호출하는 방식은 다양하다. 일반 함수 호출 메소드 호출 생성자 함수 호출 Function.prototype.apply/call/bind 메소드에 간접 호출 일반 함수 호출기본적으로 this에는 전역 객체(Global object가 바인딩된다. 전역 함수나 중첩 함수를 일반 함수로 호출하면 함수 내부의 this에는 전역 객체가 바인딩된다. 그러나 this는 객체의 프로퍼티나 메소드를 참조하기 위한 자기 참조 변수이므로 객체와는 관계없는 일반 함수에서는 this가 의미가 없다. 메소드 내에서 정의한 중첩 함수라도 일반 함수로 호출되면 중첩 함수 내부의 this에는 전역 객체가 바인딩된다. 콜백 함수 내부의 this에도 전역 객체가 바인딩된다. 어떤 함수라도 일반 함수로 호출되면 this에는 전역 객체가 바인딩된다. 메소드 호출메소드 내부의 this는 메소드를 호출한 객체, 즉 메소드 이름 앞 마침표 연산자 앞에 기술한 객체에 바인딩된다. 메소드 내부의 this는 메소드를 소유한 객체가 아닌 메소드를 호출한 객체에 바인딩된다. 이는 메소드 내부의 this가 메소드를 소유한 객체와는 관계없이 메소드를 호출한 객체에 바인딩되는 것으로 프로토타입 메소드 내부에 사용된 this도 일반 메소드와 동일하게 호출한 객체에 바인딩된다. 생성자 함수 호출생성자 함수 내부의 this에는 생성자 함수가 생성할 인스턴스가 바인딩된다. 일반 함수와 동일한 방법으로 생성자 함수를 정의하고 new 연산자와 함께 호출하면 해당 함수는 생성자 함수로 동작한다. 만약 new 연산자와 함게 생성자 함수를 호출하지 않으면 생성자 함수가 아닌 일반 함수로 호출한다. Function.prototype.apply/call/bind 메소드apply와 call 메소드는 본질적은 기능은 함수를 호출하는 것이다. bind 메소드는 apply와 call 메소드와는 달리 함수를 호출하지 않고 this로 사용할 객체만을 전달한다.","link":"/Javascript/this.html"},{"title":"전역 변수의 문제점과 var 변수의 문제점","text":"전역 변수의 문제점전역 변수의 생명주기변수는 선언에 의해 생성되고 할당을 통해 값을 갖는다. 그리고 소멸한다. 즉, 변수는 생성과 소멸의 생명주기가 있다.이 생명 주기가 없다면 한 번 선언된 변수는 프로그램을 종료하지 않는 한 영원히 메모리 공간을 점유하게 된다. 변수는 자신이 선언된 위치에서 생성되고 소멸하는데 전역 변수의 생명 주기는 애플리케이션의 생명주기와 같다. 자바스크립트는 진입점이 없고 코드가 로드되자마자 곧바로 해석되고 실행된다. 함수는 몸체이 마지막 또는 return문이 실행되면 종료한다. 하지만 전역 코드는 마지막 문이 실행되어 더 이상 실행할 문이 없어도 함수처럼 종료되지 않는다. 전역 코드의 종료는 애플리케이션의 종료와 마찬가지로 더 이상 이벤트에 대응을 할 수 없다. 그러므로 전역 변수는 브라우저를 종료하여 애플리케이션을 종료할 때 까지 유효하다. 즉 전역 변수의 생명 주기는 애플리케이션의 생명 주기와 일치한다. 이에 반해 지역 변수의 생명 주기는 함수의 생명주기와 같다. 전역 변수의 문제 암묵적 결합: 전역 변수를 사용하는 의도는 코드 어디에서나 전역 변수를 사용하겠다는 것이다. 이는 모든 코드가 전역 변수를 참조하고 변경 할 수 있는 암묵적 결합(implicit coupling)을 허용하는 것으로 변수의 유효 범위가 크면 클 수록 코드의 가독성은 나빠지고 의도치 않게 상태가 변경될 수 있는 위험성도 높아진다. 긴 생명주기: 전역 변수는 생명주기가 길다. 전역 변수의 상태를 변경할 수 있는 시간도 길고, 모든 함수가 참조할 수 있기 때문에 상태를 변경할 기회도 많다. 또한 메모리 리소스도 오랜 시간 소비된다. var 키워드는 변수의 중복 선언을 허용하므로 생명 주기가 긴 전역 변수는 변수명이 중복될 가능성이 있다. 변수명이 중복되면 의도치 않은 재할당이 이루어진다. 스코프 체인 상에서 종점에 존재: 전역 변수는 스코프 체인에서 가장 종점에 존재한다. 그렇기 때문에 변수를 검색할 때 전역 변수는 가장 마지막에 검색되어 검색 속도가 가장 느리다. 이는 큰 차이는 아니지만 분명히 속도에 차이가 발생한다. 네임 스페이스 오염: 자바스크립트는 파일이 분산되어 있어도 하나의 전역 스코프를 공유한다. 따라서 다른 파일 내에 동일한 이름으로 명명된 전역 변수나 함수가 존재하여 예상하지 못한 결과를 만들 수 있다. var 키워드ES5까지는 변수를 선언할 유일한 방법이 var 키워드를 사용하는 것이었다. var 키워드로 선언된 변수는 여러 특징이 있고 이 특징은 문제를 발생시킬 가능성이 있다. 변수 중복 선언var 키워드로 선언한 변수는 중복 선언이 가능하다. var 키워드로 선언한 변수를 다시 var 키워드로 선언을 하면 javascript는 오류를 발생시키지 않고 나중에 선언한 변수 선언문은 var 키워드가 없는 것 처럼 동작한다. 이미 선언한 변수명을 모르고 다시 선언하여 할당한다면 의도치 않게 값이 변경되는 문제가 발생하게 된다. 함수 레벨 스코프var 키워드로 선언한 변수는 오로지 함수의 코드 블록 만을 지역 스코프로 인정한다.따라서 함수 외부에서 선언한 변수는 모두 전역 변수이다. for문에서 var 키워드로 변수를 선언하여 사용하면 for문이 종료되어도 여전히 변수는 전역 변수로 존재하게 된다. 함수 레벨 스코프는 전역 변수를 남발할 가능성을 높이고 이로 인하여 전역 변수가 중복 선언되는 경우가 발생하게 된다. 변수 호이스팅var 키워드로 변수를 선언하면 변수 호이스팅에 의해 변수 선언문이 스코프의 선두로 끌어 올려진 것 처럼 동작한다. 즉 변수 호이스팅에 의해 var 키워드로 선언한 변수는 변수 선언문 이전에 참조가 가능하다. 변수 선언문 이전에 변수를 참조하는 것은 오류를 발생시키지 않지만 프로그램의 흐름상 맞지 않고 가독성을 떨어트린다.","link":"/Javascript/전역-변수의-문제점과-var-변수의-문제점.html"}],"posts":[{"title":"Javascript-1","text":"자바스크립트 개발 환경과 실행 방법자바스크립트 = ES + Web APINode.js : ES + Node.js API 자바스크립트는 브라우저에서 HTML, CSS와 함께 실행렌더링엔진 : HTML, CSS자바스크립트 엔진 : 자바스크립트 HTML 파서는 script 태그를 만나면 DOM 생성 프로세스를 중지하고 자바스크립트 엔진으로 제어 권한을 넘김자바스크립트의 실행이 완료되면 다시 HTML 파서로 제어권한을 넘겨서 브라우저가 중지했던 시점부터 DOM생성을 재개DOM이 완성되지 않은 상태에서 자바스크립트가 DOM을 조작하면 애러가 발생할 수 있다. 변수변수 : 하나의 값을 저장할 수 있는 메모리 공간에 붙인 이름 또는 메모리 공간 자체할당 : 변수에 값을 저장하는 것참조 : 변수에 저장된 값을 읽어 들이는 것식별자 : 변수명, 어떤 값을 구별하여 식별해낼 수 있는 고유한 이름변수선언 : 변수명을 등록하여 자바스크립트 엔진에 변수의 존재를 알려 관리하도록 하는 것키워드 : 자바스크립트 엔진이 수행 할 동작을 규정한 일종의 명령어 변수선언 선언단계 초기화 단계 : 암묵적 undefined 할당 var 키워드 사용시 선언단계와 초기화 단계가 동시 진행 초기화 : 변수가 선언된 후 최초 값을 할당하는 것호이스팅 : 자바스크립트 엔진은 소스 코드를 한줄씩 순차적으로 실행하기 전 소스코드 전체의 모든 선언문을 찾아내어 식별자를 등록하고 초기화, 그 후 소스코드 순차 실행 변수 선언과 값의 할당을 하나의 문으로 축약가능 재할당 : var 키워드로 선언한 변수는 값을 재할당 가능 상수 : 변수에 저장된 값을 변경할 수 없는 것 데이터 타입데이터 타입 : 값의 종류 메모리에 값을 저장하기 위해서는 확보해야 할 메모리 공간의 크기 파악, 값의 종류에 따라 확보해야 할 메모리의 크기가 다름 -&gt; 몇 byte의 공간을 사용해야 손실없이 값을 저장할 수 있는지 알아야 함을 의미 자바스크립트는 모든 숫자 타입을 64비트 부동소수점으로 저장 필요 값을 저장할 때 확보해야 하는 메모리 공간의 크기를 결정 값을 참조할 때 한번에 읽어 들여야 할 메모리 공간의 크기를 결정 메모리에서 읽어들은 2진수를 어떻게 해설할 지 결정 값 더이상 평가할 수 없는 하나의 표현식 다양한 방법(표현식)으로 생성가능 가장 기본적 방법은 리터럴 표기법 리터럴 소스코드 안에서 직접 만들어 낸 고정된 값 자체 리터럴 표기법으로 생성 값과 리터럴 표현식 : 값을 생성하는 문, 하나의 값으로 평가될 수 있는 문 리터럴은 값의 최소단위 리터럴은 값이 될 수 있지만 모든 값은 리터럴이 아님 종류 원시타입 객체타입 null : 변수에 값이 없다는 것을 의도적으로 명시, 변수가 기억하는 메모리 주소에 대한 참조 정보를 제거하는 것을 의미 자바스크립트의 변수는 선언이 아닌 할당에 의해 타입이 결정재할당에 의해 변수의 타입은 언제든지 동적으로 변화 -&gt; 동적 타이핑 변수의 수가 많을수록 오류의 발생 활률은 상승변수의 생명주기는 최대한 짧게변수보다는 상수를 사용하여 값의 변경을 억제변수명은 변수의 존재 이유를 파악할 수 있도록 명명 연산자표현식은 리터럴 표현식, 식별자 표현식, 연산자 표현식, 함수/메소드 호출 표현식 등으로 나누어지지만 결국 하나의 값을 만듬표현식 = 표현식이 평가되어 생성된 값 -&gt; 동치 문(statement) : 자바스크립트 엔진에게 내리는 명령 자바스크립트 코드 = 문 or 표현식 표현식은 값을 생성문은 표현식으로 생성한 값을 사용하여 자바스크립트 엔진에게 명령을 내리는 것 문 = 표현식인 문, 표현식이 아닌 문 존재표현식이 아닌 문은 값이 될 수 없기에 값처럼 사용 불가할당문은 그 자체가 표현식으로 값처럼 사용 가능 삼항연산자는 값으로 평가할 수 있는 표현식인 문if문은 표현식이 나닌 문으로 값으로 사용불가능 하여 삼항연산자로 사용 불가 고찰 Javascript의 모든 변수는 상수인가?Javascript에서 값을 재할당 하는 경우 메모리의 주소값이 변경.식별자는 동일해도 해당 식별자가 참조하는 메모리의 공간은 바뀌는 것이고 결국 할당된 메모리 영역에 값을 바꾸는게 아니라 새로운 할당이 일어나는 것과 같은데 그러면 하나의 값을 저장할 수 있는 메모리 공간에 붙인 이름 또는 메모리 공간 자체라는 의미에서 자바스크립트의 모든 변수는 상수인가? null타입의 값 null을 할당하면 식별자에 메모리 참조가 없어지면 식별자의 주소는 없는건가?null도 null타입의 값 null로 값으로 표현하는데 null을 할당하면 식별자의 참조가 사라지는데 그러면 참조가 사라진 식별자는 아무것도 참조를 안하는건지 아니면 null값이 들어있는 새로운 공간을 참조하고 기존 참조하던 공간이 참조가 없으면 가비지컬렉션 수행으로 사라지는건가? 참조가 없어지는거라면 null값을 주는게 아니라 아스키 0번을 변수에 주면 어떻게 되나? 이항산술연산자 +와 단항 산술연산자 +는 다른건가?0 + true = +true = 1인데 두 연산이 아예 다른 의미의 연산인가?","link":"/2019/04/30/Javascript-1/"},{"title":"Javascript vs ECMAScript","text":"Javascript = ECMAScript ?최초의 Javascript는 넷스케이프의 웹 브라우저에서 정적 HTML페이지를 동적으로 표현하기 위하여 탄생하였다. 그리고 마이크로소프트에서 이 Javascript의 파생 버전인 JScript를 만들었다. 당시 웹브라우저 시장은 넷스케이프가 압도적이었으나 MS사가 Windows에 자신들의 웹브라우저를 끼워팔면서 점유율은 역전되었다. 이 때 많은 웹브라우저 제조사들은 자사의 브라우저에서만 동작하는 기능을 경쟁적으로 만들면서 Javascript의 파편화가 극심해졌다. 이런 각 벤더 사마다 다른 Javascript를 표준화하기 위하여 넷스케이프가 ECMA 인터내셔널에 표준화를 요청하였고 그렇게 탄생한 것이 ECMAScript이다. 그러나 당시 막강한 점유율로 시장에서 압도적 우위에 있던 MS사의 미온한 참여로 당시 ECMAScript 버전은 많은 문제가 있었다. 그 후 Google의 Chrome이 IE의 점유율을 끌어내리면서 ESMAScript5(ES5)가 제정되면서 표준화 문제가 어느정도 해결되기 시작하였다. 이렇게 여러 밴드사가 공통으로 지원하는 Javascript의 Core를 ES = ESMAScript라고 한다. 그 외에 각 벤더의 브라우저가 별도로 지원하는 Web API는 어전히 존재하고 있다.즉, 자바스크립트 = ES + Web API 와 같다. Node.js에서 Web API?기본적으로 Javascript를 구동하는 환경은 브라우저이다. 그러나 Node.js의 등장으로 Javascript로 브라우저 밖에서 서버를 구축하는 등의 코드를 실행 할 수 있게 되었다. 그렇다면 두 환경은 같은가? 크롬 브라우저와 Node.js는 모두 V8엔진을 사용한다. 하지만 Node.js에서 Web API는 사용이 불가능하다. 브라우저 : html, css + js Node.js 환경 : ES + Node.js API 브라우저에서 Web API의 관리는 V8엔진이 담당하지만 V8엔진을 사용한 Node.js는 Web API는 지원되지 않는다. 이는 브라우저에서 Web API에 대한 기능은 내부적으로는 V8엔진이 하지만 기본적으로는 ES코드를 실행하는 엔진이기 때문에 같은 V8엔진을 사용하는 Node.js에서는 실행이 되지 않느다.","link":"/2019/04/29/Javascript-ES/"},{"title":"express설치하고 helloworld 출력하기 feat 포트 열기","text":"AWS STUDY PuTTY로 aws ec2로 만든 리눅스 환경 접속하기 ec2에-npm-설치 express설치하고 helloworld 출력하기 feat 포트 열기 express설치메뉴얼을 보고 express를 설치합시다. 1. 폴더를 만들고 들어갑시다.1$ mkdir myApp &amp;&amp; cd myApp 2. npm init1$ npm init -y -y를 붙여주면 지가 좀 알아서 해줍니다. 3. script를 수정1$ vi package.json package.json을 열어서 script에 test를 지우고 start를 만들어 줍니다. 4. myApp.js12345678910var express = require('express');var app = express();app.get('/', function (req, res) { res.send('Hello World!');});app.listen(3000, function () { console.log('Example app listening on port 3000!');}); myApp.js 파일을 만든 후 위 소스를 넣어줍니다. 5. 실행1$ npm start 서버가 돌아갑니다. 인스턴스를 만들 때 확인했던 IPv4 퍼블릭 IP 주소를 이용하여 접속해봅니다.브라우저에서 IPv4 퍼블릭 IP:3000을 입력합니다. 6. 안되네?페이지를 표시할 수 없습니다. 난 안될 줄 알았어. 그냥 켠김에 해본거야. 진짜 7. port를 열자인스턴스의 정보를 확인했던 화면으로 갑니다. 아래 보안 그룹에서 인바운드 규칙 보기를 클릭하면 하나 밖에 없습니다. 그 좌측을 클릭합니다.(이름은 다를 수 있음. 확인 안해 봄) 인바운드 - 편집 클릭 규칙 추가를 클릭하고 사용자 지정 TCP를 선택하야 myApp에서 사용하는 포트 3000을 추가하고 저장합니다. 8. 끝브라우저에서 새로고침해보면 Hello World!가 뽝","link":"/2019/06/08/aws-express-helloworld-port/"},{"title":"PuTTY로 aws ec2로 만든 리눅스 환경 접속하기","text":"AWS STUDY PuTTY로 aws ec2로 만든 리눅스 환경 접속하기 ec2에-npm-설치 express설치하고 helloworld 출력하기 feat 포트 열기 ec2 만들기aws의 ec2와 putty를 이용하여 리눅스에 개발공간을 만들고 연결하기aws가입 필요. 인스턴스 생성가난한 저는 프리티어의 ec2를 생성하여 사용합니다. 리눅스 초짜 리알못은 일단 아마존 리눅스를 사용하겠습니다. 1. 우측 상단 내 계정 - AWS Management Console을 클릭 2. 솔루션 구축 - EC2를 사용하여 클릭 3. 단계 1: Amazon Machine Image(AMI) 선택 - Amazon Linux AMI 2018.03.0 (HVM), SSD Volume Type 클릭 4. 단계 2: 인스턴스 유형 선택 - 기본 선택 상태에서 검토 및 시작 클릭 5. 단계 7: 인스턴스 시작 검토 - 시작하기 클릭6. 키 페어 생성새 키 페어 생성을 선택하고키 페어 이름에서 키의 이름을 주고 키 페어 다운로드를 클릭하여 키 페어 다운 인스턴스 정보 확인인스턴스 상태가 running이면 우리의 컴퓨터가 정상적으로 동작하고 있는 중 입니다.우리는 퍼블릭 DNS를 이용하여 putty에서 접속을 할 겁니다.IPv4 퍼블릭 IP는 추후 서버를 구동해서 외부에서 접속을 할 떄 사용할 겁니다.아마도… PuTTY로 접속하기PuTTy 설치하기. PuTTYgen키 페어 다운로드를 통해서 받은 파일을 ppk로 변경해야 함. PuTTygen을 실행하여 Load를 클릭 우측 파일 타입을 All Files를 선택하고 키 페어 다운로드에서 받은 파일 선택 확인 창이 뜨면 누르고 Save private key를 클릭하여 .ppk파일 저장 연결PuTTY를 실행ec2의 User Name은 ec2-user입니다.Host Name에 user name@퍼블릭 DNS을 입력합니다. 좌측 Category - Connection - Auth - Private key file for authertication에 위에서 만든 .ppk파일을 불러오고Open! 끝~!","link":"/2019/06/07/aws-putty-ec2/"},{"title":"ec2 아마존 리눅스에 MonogoDB install","text":"AWS STUDY PuTTY로 aws ec2로 만든 리눅스 환경 접속하기 ec2에-npm-설치 express설치하고 helloworld 출력하기 feat 포트 열기 ec2 아마존 리눅스에 MonogoDB install MonogoDB installInstall MongoDB Community Edition on Amazon Linux을 참고하여 설치합시다. 설치1. Configure the package management system (yum). vi로 /etc/yum.repos.d/mongodb-org-4.0.repo을 열어서 123456[mongodb-org-4.0]name=MongoDB Repositorybaseurl=https://repo.mongodb.org/yum/amazon/2013.03/mongodb-org/4.0/x86_64/gpgcheck=1enabled=1gpgkey=https://www.mongodb.org/static/pgp/server-4.0.asc 을 넣어줍니다. 저장이 안된다면 vi를 열 때 sudo를 이용하면 됩니다. 저는… 2. Install the MongoDB packages 1$ udo yum install -y mongodb-org 3. 실행확인 2. Install the MongoDB packages에서 Complete!가 나왔다면 성공입니다. 1$ sudo service mongod start ok를 확인 할 수 있습니다. 1$ sudo mongo mongodb의 shell을 실행할 수 있습니다. 1$ sudo service mongod stop bye~ 로컬에서 접속해보기1. aws에 포트 열기express설치하고 helloworld 출력하기 feat 포트 열기에서 진행했던 포트 열기를 또 합니다. 이번에는 27017를 추가합니다. 2. MongoDB conf 수정db가 stop된 상태에서 진행합니다. 1sudo vi /etc/mongod.conf 를 이용하여 conf파일을 열어줍니다. 127.0.0.1을 0.0.0.0으로 변경해줍니다. local의 MongoDB compass community에서 확인 IP를 채워넣고 CONNECT를 눌러줍니다. 접속~ 테스트 local에서 실행한 server에 ec2에 설치한 MongoDB를 연결하여 정상 동작 /var/run/mongodb/mongod.pid exists 에러가 발생하는 경우1234sudo rm /var/run/mongodb/mongod.pidsudo chown mongod:mongod /tmp/mongodb-27017.sockservice mongod status 실행","link":"/2019/06/09/aws-mongodb-install/"},{"title":"ec2에 npm 설치","text":"AWS STUDY PuTTY로 aws ec2로 만든 리눅스 환경 접속하기 ec2에-npm-설치 express설치하고 helloworld 출력하기 feat 포트 열기 yum update일단 yum을 update1sudo yum update nvm 설치 https://docs.aws.amazon.com/ko_kr/sdk-for-javascript/v2/developer-guide/setting-up-node-on-ec2-instance.html aws문서를 참고하여 설치 명령줄에 다음을 입력하여 nvm(노드 버전 관리자)을 설치합니다. 1curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.32.0/install.sh | bash 명령줄에 다음을 입력하여 nvm을 활성화합니다. 1. ~/.nvm/nvm.sh 명령줄에 다음을 입력하여 nvm에서 사용하려는 Node.js 버전을 설치합니다. 1nvm install 4.4.5 node 새 버전 설치nvm install v10.15.3 설치 저 버전은 그냥 내가 PC에서 사용하는 버전이라 설치한거고 더 상위버전이나 다른 버전 설치해도 무방 끝~!","link":"/2019/06/07/aws-ec2npm/"},{"title":"box-sizing","text":"box-sizing과 box modelbox의 크기를 어떤 기준으로 계산 할 것인가? HTML은 Box로 이루어져 있으며 문서의 레이아웃을 계산 할 때 박스 모델에 따라 박스의 사이즈가 달라지게 됨 box의 크기는 어떤 요소들로 이루어 지는가? box의 크기에 영향을 주는 요소는 box의 width, height, border, padding, margin이 됨 각 요소의 값이 동일 할 때 box의 크기는 달라지는가?12&lt;div class=\"div content\"&gt;content-box&lt;/div&gt;&lt;div class=\"div border\"&gt;border-box&lt;/div&gt; 1234567891011121314.div{ width: 100px; height: 100px; background: pink; border:10px solid black; padding: 10px; margin: 20px;}.content{ box-sizing: content-box;}.border{ box-sizing: border-box;} 다음과 같은 html과 css가 있을 때 두 div는 .div의 스타일을 적용받아 동일한 size가 됨 그러나 두 div는 box-sizing이 각각 content-box와 border-box로 box-sizing의 값이 다름 그 결과 두 div는 전혀 다른 크기를 갖게 됨 왜 두 div는 다른 크기가 되었는가? 위는 content, 아래는 border의 사이즈 content-box는 100x100의 사이즈에 추가적으로 10px의 padding, 10px의 border와 20px의 margin을 추가적으로 갖게 되어 총 140x140의 사이즈를 갖게 됨 border-box는 100x100의 사이즈를 10px의 border와 padding이 함께 갖게 됨 즉 content-box에서 height와 width는 box의 content의 크기이며 그 외 padding과 margin, border의 크기를 추가로 갖음 border-box는 border까지는 크기를 함게 갖고 margin의 크기를 추가로 갖게 됨","link":"/2019/04/18/box-sizing/"},{"title":"call_by_Value, call_by_Reference","text":"Call by Value 와 Call by ReferenceCall by Value12345678910void change_value(int x, int val) { x = val; printf(\"x : %d in change_value \\n\", x);}int main(void) { int x = 10; change_value(x, 20); printf(\"x : %d in main \\n\", x);} 위 소스는 main에서 선언된 변수 x에 값 10을 주고 변수 x와 정수 val 매개변수로 하여 change_value를 호출한 후 change_value에서 x의 값을 val로 변경하는 소스이다. 실행을 하면 change_value에서 x의 값은 20으로 변경되었지만 main에서는 여전히 10이다. 이는 main에서 넘긴 x는 x의 값 10을 의미하기 때문에 이것을 바꾸어도 main의 x는 영향을 받지 않는다. 그래서 Call by Value이다. Call by Reference그렇다면 change_value에서 main의 x의 값을 어떻게 변경하는가?123456789101112#include &lt;stdio.hvoid change_value(int * x, int val) { *x = val; printf(\"x : %d in change_value \\n\", *x);}int main(void) { int x = 10; change_value(&amp;x, 20); printf(\"x : %d in main \\n\", x);} 위 소스는 Call by Value와 거의 흡사하지만 결과는 다르다. 값이 변경되었다! 왜?! main이 change_value를 호출 할 때 x의 값을 넘긴게 아니라 x의 주소를 넘겨 change_value에서 x의 주소의 값을 변경하여 main의 x의 값이 바뀌게 된다. 아닌데! 그거 Call by Address인데!맞다. 사실 이것은 Call by Reference가 아니라 Call by Address라 부르는 그것이다. 주소를 넘겼는데 이 주소도 주소값 즉, 값이다. 그러니 Call by Value인데 주소를 넘겼기에 Call by Address라 부르는 것이다. visual studio에서 change_value의 x값을 보면 위와 같다. x에는 주소값이 들어있고 그 주소에는 20이 들어있다. *x = val; 은 그 x의 주소에 들어있는 값을 val로 바꾸는 것이다. 그렇기에 x의 주소는 따로 존재한다. 즉 x라는 변수는 따로 메모리주소를 갖고 있으며 그 메모리 주소에는 값으로 주소를 가지고 있다. 그 가지고 있는 주소의 값은 main의 변수 x의 주소이기에 그 x의 주소를 가지고 값을 변경하는 것이다. change_value에서 x가 가지고 있는 값은 main에서 x의 주소와 동일하다. 주소값도 값이기 때문에 Call by Value이고 주소값이기 때문에 일반 값과 구분하여 Call by Address이다. C에는 포인터만 있지만 C++에는 참조자가 있지!이와 동일한 소스를 C++로 해보면 역시나 동일하다. 1234567891011121314#include&lt;iostreamusing namespace std;void change_value(int * x, int val) { *x = val; cout &lt;&lt; \"x : \" &lt;&lt; *x &lt;&lt; \" in change_value\" &lt;&lt; endl;}int main(void) { int x = 10; change_value(&amp;x, 20); cout &lt;&lt; \"x : \" &lt;&lt; x &lt;&lt; \" in main\" &lt;&lt; endl;} 하지만 이 소스를 참조자를 이용하여 짤 수 있다. 1234567891011121314#include&lt;iostreamusing namespace std;void change_value(int &amp;x, int val) { x = val; cout &lt;&lt; \"x : \" &lt;&lt; x &lt;&lt; \" in change_value\" &lt;&lt; endl;}int main(void) { int x = 10; change_value(x, 20); cout &lt;&lt; \"x : \" &lt;&lt; x &lt;&lt; \" in main\" &lt;&lt; endl;} 위 change_value에서 x에는 정수 값이 들어있고 x의 주소는 main에서 x의 주소와 동일하다. 오오! c++에서 참조자를 이용한 함수 호출에서는 진정으로 Call by Reference가 이루어지는 것이다. c에는 참조자가 없지? 아마? 그렇기에 Call by Address다. 어차피 컴파일러는 주소로 연산한다.Call by Value, Call by Reference, Call by Address 다 값을 전달하는 건 똑같다. Call by Reference는 호출 할 때 값을 전달하는 것처럼 보이지만 포인터로 받는거다. 다 똑같다. 어차피 컴파일러는 주소로 연산한다. 코드에서 선언을 포인터와 참조자 중 뭐로 했냐의 차이다. C언어의 창시자인 데니스 리차드가 쓴 The C Programming Language를 보자. C언어는 값으로 인자를 전달한다. Call by Reference는 호출 된 함수는 복사본이 아닌 원래 인수에 액세스 할 수 있는건데 결국 Call by Address도 주소값을 이용하여 원래 인수의 값을 바꾼다. 순서대로 Call by Value, Call by Address, Call by Reference다. Call by Value는 call stack에서 호출된 함수는 호출을 한 main의 인자에 접근 할 수 없다. 나머지 둘은 접근한다. 함수가 자신의 stack frame의 인수에만 영향을 줄 수 있다면 Call by Value이고 자신을 호출한 stack frame에 인수를 변경 가능하다면 Call by Reference이기에 결국 주소를 이용하여 값을 변경하는 Call by Address도 값을 이용하지만 Call by Reference의 의미에 맞는게 아닌가 싶다.","link":"/2019/04/22/call-by-Value-call-by-Reference/"},{"title":"TypeError-is-not-a-function","text":"증상JQuery의 stop, animate 를 사용 할 때 TypeError발생TypeError: $(…).stop is not a function 원인JQuery의 $가 다른 라이브러리에서도 함수나 변수의 이름으로 사용됨 Bootstrap의 Getting started에서 JS를 추가 할 때 JQuery가 중첩되어 문제가 발생 해결Bootstrap에서 추가한 JQuery를 제거 하면 해결 추가jQuery.noConflict() 사용으로도 가능 123456789101112131415161718var jq = jQuery.noConflict(); jq('.menu-icon.left-icon').click(function () { jq('body #wrapped').stop().animate({ \"left\": \"-0\" }, 1500);});jq('.menu-icon.right-icon').click(function () { jq('body #wrapped').stop().animate({ \"left\": \"-400px\" }, 1500);});jq('.close-icon').click(function () { jq('body #wrapped').stop().animate({ \"left\": \"-200px\" }, 1500);}); 참고 jQuery.noConflict()","link":"/2019/03/19/TypeError-is-not-a-function/"},{"title":"codility Lesson2 CyclicRotation","text":"CyclicRotation1234567891011121314151617181920212223242526272829303132333435363738An array A consisting of N integers is given. Rotation of the array means that each element is shifted right by one index, and the last element of the array is moved to the first place. For example, the rotation of array A = [3, 8, 9, 7, 6] is [6, 3, 8, 9, 7] (elements are shifted right by one index and 6 is moved to the first place).The goal is to rotate array A K times; that is, each element of A will be shifted to the right K times.Write a function: def solution(A, K)that, given an array A consisting of N integers and an integer K, returns the array A rotated K times.For example, given A = [3, 8, 9, 7, 6] K = 3the function should return [9, 7, 6, 3, 8]. Three rotations were made: [3, 8, 9, 7, 6] -[6, 3, 8, 9, 7] [6, 3, 8, 9, 7] -[7, 6, 3, 8, 9] [7, 6, 3, 8, 9] -[9, 7, 6, 3, 8]For another example, given A = [0, 0, 0] K = 1the function should return [0, 0, 0]Given A = [1, 2, 3, 4] K = 4the function should return [1, 2, 3, 4]Assume that: N and K are integers within the range [0..100]; each element of array A is an integer within the range [−1,000..1,000].In your solution, focus on correctness. The performance of your solution will not be the focus of the assessment.Copyright 2009–2019 by Codility Limited. All Rights Reserved. Unauthorized copying, publication or disclosure prohibited. 방법배열 A의 크기를 N으로 하였을 때 N의 요소들을 K만큼 옮기기 위하여 N의 요소들의 index값에 K를 더하여 해결N의 inedx+K의 값이 N의 전체 길이보다 클 경우 0부터 증가시킴위 방법을 그대로 사용 할 경우 반복이 많아짐N의 길이가 5이고 K가 3이라고 할 경우 N[0]의 값은 N[3]이 되며 N[4]는 N[7]이 되어 0부터 다시 계산하면 N[2]가 됨K의 값이 N의 길이보다 많이 클 경우를 생각하여 %연산을 이용즉 본래 index+K의 값을 N의 길이로 나눈 나머지 값을 새로운 index로 사용N[4]는 N[7]되고 7%5=2가 됨 코드1234567891011121314151617181920import copydef solution(A, K): # write your code in Python 3.6 n = len(A) #return [9, 7, 6, 3, 8]. result = copy.deepcopy(A) if n==0 or K%n==0: return A else: for i in range(n): index = (i+K)%n result[index] = A[i] return result pass 추가오늘 python을 배운김에 python으로 작성해봄 결과","link":"/2019/04/19/codility-2-2-CyclicRotation/"},{"title":"codility Lesson1 BinaryGap","text":"BinaryGap1234567891011121314151617A binary gap within a positive integer N is any maximal sequence of consecutive zeros that is surrounded by ones at both ends in the binary representation of N.For example, number 9 has binary representation 1001 and contains a binary gap of length 2. The number 529 has binary representation 1000010001 and contains two binary gaps: one of length 4 and one of length 3. The number 20 has binary representation 10100 and contains one binary gap of length 1. The number 15 has binary representation 1111 and has no binary gaps. The number 32 has binary representation 100000 and has no binary gaps.Write a function: function solution(N);that, given a positive integer N, returns the length of its longest binary gap. The function should return 0 if N doesn&apos;t contain a binary gap.For example, given N = 1041 the function should return 5, because N has binary representation 10000010001 and so its longest binary gap is of length 5. Given N = 32 the function should return 0, because N has binary representation &apos;100000&apos; and thus no binary gaps.Write an efficient algorithm for the following assumptions: N is an integer within the range [1..2,147,483,647].Copyright 2009–2019 by Codility Limited. All Rights Reserved. Unauthorized copying, publication or disclosure prohibited. 기본input : 37입력된 값 N을 2진수로 변경하였을 때 1과 1 사이의 가장 많은 0의 수를 계산하는 문제로 N을 2로 나누어 떨어지는 경우는 0으로 나누어 지지 않는 경우는 1이기 때문에 나머지가 0인 경우 숫자를 카운트 10진수 37의 경우 2진수로 100101이며 2로 나눈 값은 10진수로 18과 나머지 1, 2진수로 10010과 나머지 1이 된다. 2로 나누어 지지 않는 경우 나머지는 2진수의 가장 오른쪽 1이고 이 후 2로 나누어지는 경우 2진수에서 가장 오른쪽에 다시 1이 올 때까지 0의 갯수를 카운트한다. 기본 cnt는 0이기 때문에 2진수로 1, 10, 100 등과 같이 1이 하나만 존재하는 수는 cnt의 값이 증가하지 않는다. 추가2진수 1000100000과 같이 끝이 1로 끝나지 않는 2진수는 결국 10001만 필요하고 100000은 오른족이 1이 아니기 때문에 숫자를 카운트 할 필요가 없기 때문에 right shift연산을 한다. 2진수 2는 10이기 때문에 1000100000가 10001이 될 때까지 right shift를 하여 10001을 만든다.이 부분은 shift연산이 아닌 N/2연산을 통해 2진수 10으로 나누어도 동일한 결과를 얻을 수 있다. 추가2 부분을 나누기로 할 경우 javascript는 모든 숫자가 double형이기 때문에 N을 2로 나눈 후 소수점을 버린다. 코드1234567891011121314151617181920212223242526function solution(N) { // write your code in JavaScript (Node.js 8.9.4) var cnt = 0; var max = -1; //추가1 while (N % 2 == 0) { N = N 1; } while (N 0) { if (N % 2 == 0) { cnt++; } else { max = Math.max(cnt, max); cnt = 0; } N = N 1; //추가2 } return max;} 결과","link":"/2019/04/17/codility-1-1-BinaryGap/"},{"title":"codility Lesson3 TapeEquilibrium","text":"TapeEquilibrium123456789101112131415161718192021222324252627282930313233343536373839404142434445A non-empty array A consisting of N integers is given. Array A represents numbers on a tape.Any integer P, such that 0 &lt; P &lt; N, splits this tape into two non-empty parts: A[0], A[1], ..., A[P − 1] and A[P], A[P + 1], ..., A[N − 1].The difference between the two parts is the value of: |(A[0] + A[1] + ... + A[P − 1]) − (A[P] + A[P + 1] + ... + A[N − 1])|In other words, it is the absolute difference between the sum of the first part and the sum of the second part.For example, consider array A such that: A[0] = 3 A[1] = 1 A[2] = 2 A[3] = 4 A[4] = 3We can split this tape in four places: P = 1, difference = |3 − 10| = 7 P = 2, difference = |4 − 9| = 5 P = 3, difference = |6 − 7| = 1 P = 4, difference = |10 − 3| = 7Write a function: function solution(A);that, given a non-empty array A of N integers, returns the minimal difference that can be achieved.For example, given: A[0] = 3 A[1] = 1 A[2] = 2 A[3] = 4 A[4] = 3the function should return 1, as explained above.Write an efficient algorithm for the following assumptions: N is an integer within the range [2..100,000]; each element of array A is an integer within the range [−1,000..1,000].Copyright 2009–2019 by Codility Limited. All Rights Reserved. Unauthorized copying, publication or disclosure prohibited. 방법배열의 요소를 둘로 나누어 좌측 합과 우측합의 차를 절대값으로 계산하여 가장 작은 값을 찾는다.좌측은 첫 요소부터 마지막요소를 제외한 나머지 요소의 합까지이며우측은 첫 요소를 제외한 나머지의 합부터 마지막 요소까지 A[0] = 3 A[1] = 1 A[2] = 2 A[3] = 4 A[4] = 3일 때,3+1+2+4+5 = 13 이며,|3 - (1+2+4+3)| 부터 |(3+1+2+4)-3|까지 이므로마지막 요소는 좌측의 합이 아니기 때문에 반복문은 A.length-1 코드1234567891011121314function solution(A) { const getSum = (accumulator, currentValue) =&gt; accumulator + currentValue; let right = A.reduce(getSum); let left = 0; let min = 10001; for (let i = 0; i &lt; A.length - 1; i++) { left += A[i]; right -= A[i]; min = Math.min(Math.abs(left - right), min); } return min;} 결과","link":"/2019/05/05/codility-3-1-TapeEquilibrium/"},{"title":"codility Lesson2 OddOccurrencesInArray","text":"OddOccurrencesInArray1234567891011121314151617181920212223242526272829303132A non-empty array A consisting of N integers is given. The array contains an odd number of elements, and each element of the array can be paired with another element that has the same value, except for one element that is left unpaired.For example, in array A such that: A[0] = 9 A[1] = 3 A[2] = 9 A[3] = 3 A[4] = 9 A[5] = 7 A[6] = 9 the elements at indexes 0 and 2 have value 9, the elements at indexes 1 and 3 have value 3, the elements at indexes 4 and 6 have value 9, the element at index 5 has value 7 and is unpaired.Write a function: function solution(A);that, given an array A consisting of N integers fulfilling the above conditions, returns the value of the unpaired element.For example, given array A such that: A[0] = 9 A[1] = 3 A[2] = 9 A[3] = 3 A[4] = 9 A[5] = 7 A[6] = 9the function should return 7, as explained in the example above.Write an efficient algorithm for the following assumptions: N is an odd integer within the range [1..1,000,000]; each element of array A is an integer within the range [1..1,000,000,000]; all but one of the values in A occur an even number of times.Copyright 2009–2019 by Codility Limited. All Rights Reserved. Unauthorized copying, publication or disclosure prohibited. 방법xor을 이용0과 어떤 수 n을 xor 연산하면 n이된다.000 xor 101의 결과는 101이다.어떤 수 n에 x를 짝수번 xor연산 할 경우 그 값은 n과 동일하다.10진수 5은 2진수로 101이고 10진수 3은 2진수로 011이다.101 xor 011의 결과는 110 이고 110 xor 011의 결과는 101이 된다.즉 0에 짝수개 만큼 존재하는 수들을 xor연산하면 그 결과는 0이 되고 짝수개가 존재하는 수들 가운데 홀수개가 존재하는 수를 xor하면 결국 홀수개가 존재하는 수의 값이 남는다.0에 7, 5, 7, 4, 5를 xor연산하면 7과 5는 두 개씩 존재하기 때문에 0이되고 하나만 존재하는 4의 값만 남는다. 코드123456789function solution(A) { // write your code in JavaScript (Node.js 8.9.4) var result = 0; for(var i=0; i&lt;A.length; i++){ result = result^A[i]; } return result;} 결과","link":"/2019/04/19/codility-2-1-OddOccurrencesInArray/"},{"title":"2019-04-04 TIL","text":"그라데이션background-image: linear-gradient(red, green) : 위에서 아래, 레드에서 그린 background-image: linear-gradient(to right, red, green) https://webgradients.com/https://leaverou.github.io/css3patterns/ http://www.colorzilla.com/gradient-editor/ background배경 다중 선언시 가장 먼저 선언 한 요소가 가장 위background: #e25d2d linear-gradient(…)네트워크 이슈 등으로 그라데이션을 제대로 못 반영 하는 경우 앞에 속성의 값으로 색을 표시 - 콜백background: #fff url(“./images/bg_flower.png”) no-repeat;배경이미지 반복 X단축표기법은 마지막꺼만이미지 반복 off : background-repeat: no-repeat; float, position, inline-blockinline-block 사용시 공백 발생float 설정시 높이를 잊어버림, 부모가 높이를 가지고 있으면 해결됨position은 offset을 주지 않으면 본래 있던 자리에 위치레이아웃은 가장 마지막에 마크업 한 요소가 가장 위로 올라옴flex는 줄바꿈을 허용하지 않음, 필요시 wrap 사용 white-space: nowrap;block에 사용block 속성의 부모에게 추가를 하여 block의 개행을 강제로 막음 http://fontello.com/가벼운 이미지폰트 특수문자https://www.w3schools.com/html/html_entities.asp 애니메이션12345&lt;div class=\"visual\"&gt; &lt;p class=\"visual-text\"&gt; Web Standards &amp;amp; Accessibility &lt;/p&gt;&lt;/div&gt; 12345678910111213141516171819202122232425262728@keyframes textAni{ 0%{ font-size: 12px; color: rgba(0, 0, 0, 0); /* padding: 0; */ top: 0; left: 0;; } 100%{ font-size: 24px; color: rgba(0, 0, 0, 1); /* padding: 75px 0 0 400px; */ top: 75px; left: 400px; }}.visual{ height: 120px; position: relative;}/* 텍스트 에니메이션 */.visual-text{ position: absolute; background: yellow; animation-name: textAni; animation-duration: 2000ms; animation-fill-mode: forwards;} 브라우저가 애니메이션을 사용하면 다시 그리기 때문에 느려짐12345678910111213141516171819202122232425@keyframes textAni{ 0%{ font-size: 12px; color: rgba(0, 0, 0, 0); transform: translate(0, 0); } 100%{ font-size: 24px; color: rgba(0, 0, 0, 1); transform: translate(400px, 75px); }}.visual{ height: 120px; position: relative;}/* 텍스트 에니메이션 */.visual-text{ /* position: absolute; */ display: inline-block; background: yellow; animation-name: textAni; animation-duration: 2000ms; animation-fill-mode: forwards;} 다시 그리지 않아서 속도가 더 빠름 12345678910111213.visual::before, .visual::after{ content:\"\"; position: absolute; width: 100%; height: 100%; top: 0; left: 0; background-repeat: no-repeat;}.visual::before{ background-image: url(\"./images/ani_flower_01.png\"), url(\"./images/ani_flower_02.png\"); background-position: 0 -10px, 670px 0; } background: url(“./images/ani_flower_01.png”); 를 사용하면 repeat가 위에서 선언되어 아래에서 풀림, 대표가 아닌 background-image 사용으로 해결 .visual::before, .visual::after{ 와 .visual::before{ 위치를 변경해도 가능","link":"/2019/04/04/fc-190404/"},{"title":"2019-04-01 TIL","text":"flexmain에 display를 flex로 설정 &lt;brflex-direction을 이용하여 가로로 정렬 &lt;brjustify-content를 이용하여 group1~3의 사이를 균등하게 분할 &lt;brIE11에서 이용 불가&lt;brhttps://css-tricks.com/snippets/css/a-guide-to-flexbox/ floatIE11에서 flex의 사용이 불가하여 IE11 호환이 필요한 경우 사용가능 &lt;brgroup에 float 속성을 주어 가로로 정렬 &lt;brfloat 속성을 가진 group들이 공간을 차지하지 않아 아래 main 아래의 element들이 위로 당겨짐&lt;br이를 해결하기 위하여 ::after를 이용하여 가상의 element를 만들어 clear 속성을 줌","link":"/2019/04/01/fc-190401/"},{"title":"codility-3-2-FrogJmp","text":"FrogJmp1234567891011121314151617181920212223242526272829A small frog wants to get to the other side of the road. The frog is currently located at position X and wants to get to a position greater than or equal to Y. The small frog always jumps a fixed distance, D.Count the minimal number of jumps that the small frog must perform to reach its target.Write a function: function solution(X, Y, D);that, given three integers X, Y and D, returns the minimal number of jumps from position X to a position equal to or greater than Y.For example, given: X = 10 Y = 85 D = 30the function should return 3, because the frog will be positioned as follows: after the first jump, at position 10 + 30 = 40 after the second jump, at position 10 + 30 + 30 = 70 after the third jump, at position 10 + 30 + 30 + 30 = 100Write an efficient algorithm for the following assumptions: X, Y and D are integers within the range [1..1,000,000,000]; X ≤ Y.Copyright 2009–2019 by Codility Limited. All Rights Reserved. Unauthorized copying, publication or disclosure prohibited. 설명X : 시작 위치Y : 도착 위치D : 증가량 X+nD &gt; Y의 n을 구하기도착위치에서 시작위치를 뺀 후 증가량 D로 나누기다른 언어의 경우 기본적으로 정수형 연산이기 때문에 나머지가 있으면 몫+1 이지만javascript는 기본적으로 모든 숫자의 연산이 정수가 아닌 실수형이기 때문에 올림으로 계산하면 됨 코드1234function solution(X, Y, D) { // write your code in JavaScript (Node.js 8.9.4) return Math.ceil((Y - X) / D);} 결과","link":"/2019/05/06/codility-3-2-FrogJmp/"},{"title":"2019-04-05 TIL","text":"form상호작용필수 요소로 action을 가짐(주소) fieldset : 연관성 있는 서식의 묶음 legend : fieldset의 목적 label : 입력서식에 대한 표시, 모든 입력서식은 label을 가져야 함 암묵적 label : label 안에 input을 넣는 방법명시적 label ; label에 for를 이용하여 input의 id를 입력 required 논리속성submit의 action으로 데이터 전송 전 browser에서 필수값을 확인 placeholder 안에 들어올 값 이나 값의 힌트를 미리 입력 / label과 동일하게 많이 사용하나 다름 inputtype https://seulbinim.github.io/WSA/form.html#input-%EC%9A%94%EC%86%8Chttps://miketaylr.com/pres/html5/forms2.html text-indent들여쓰기block에서만 가능음수값이면 내여쓰기 letter-spacing:자간조절","link":"/2019/04/05/fc-190405/"},{"title":"2019-04-02 TIL","text":"css 중요도상속&lt;br겹침&lt;br우선순위 HTML 중요도 = box modelpositionfloatdisplayblock inlinebrinline-blockflexgird 상속 배치와 관련된 항목은 상속X 데코레이션 관련만 상속 / background 관련X 속성값이 inherit이면 무조건 부모 상속 em 단위는 부모에게 상속 / rem은 root에게서 상속 우선순위 e &lt; c &lt; i &lt; inline-style 선택자 [class^=”box”] = box로 시작하는 모든 class ^ : 시작 / $ 끝 1234[class^=\"box\"]{ background: pink; color: green !important;} !important 강제로 우선순위 무시 position block으로 바뀜 absolute : [display: flex]는 내용이 겹치지 않아 lineguard가 가능하지만 absolute는 가림 / 상위 부모 요소 중 가장 가까운 static이 아닌 부모요소를 기준으로 움직임 #마진병합 요소 사이의 마진의 병합, normal flow일때만 가능 Noto sans = spoqa han sans Noto : google spoqa : adobe Noto는 FF에서 정상 동작이 안되는 경우 발생 inline 이슈1&lt;li&gt;&lt;a href=\"#\"&gt;홈&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=\"#\"&gt;로그인&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=\"#\"&gt;회원가입&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=\"#\"&gt;사이트맵&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=\"#\"&gt;english&lt;/a&gt;&lt;/li&gt; 1234567&lt;ul class=\"member\"&gt; &lt;li&gt;&lt;a href=\"#\"&gt;홈&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;로그인&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;회원가입&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;사이트맵&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;english&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt; inline에서 enter값이 공백으로 인식됨 &lt;li&gt;의 부모인 member의 font-size를 0으로 하여 상속하고 li의 글자크기를 키우면 해결 구조선택자 http://nthmaster.com/ tabindex=0 tab으로 마크업순서 이동가능 숨김 display:none = 처음부터 없던 것 처럼 / 화면 뿐 아니라 다른 보조기구로도 인식 불가 position: absolute = 절대값으로 화면 밖으로 옮김 / 모바일 환경에서 가상커서 문제 발생 opacity: 0 = 투명도 인지가 안되는 문제 발생 할 수 있음 12345678.readable-hidden{ position: absolute; width: 1px; height: 1px; overflow: hidden; margin: -1px; clip: rect(0 0 0 0);} https://seulbinim.github.io/WSA/float-position.html#clip-%EC%86%8D%EC%84%B1 spac out 예정 https://css-tricks.com/almanac/properties/c/clip/","link":"/2019/04/03/fc-190402/"},{"title":"2019-04-11 TIL","text":"새소식 마크업내 마크업12345678910section.news h2.news-header a.news-link article.news-item h3.news-item-subject time p.news-item-brief span img a.news-more 강사님 마크업 12345678910section.news h2.news-heading article.news-item h3.news-item-subject time.news-item-date p.news-item-brief figure.news-item-thumbnail img figcaption a.news-more figurecaption을 달기 위한 마크업 적절한 예 부적절한 예 html1234567891011121314151617&lt;section class=\"news clearfix\"&gt; &lt;h2 class=\"news-heading\"&gt;새소식&lt;/h2&gt; &lt;article class=\"news-item clearfix\"&gt; &lt;a href=\"#\"&gt; &lt;h3 class=\"news-item-subject\"&gt;W3C 사이트가 리뉴얼 되었습니다.&lt;/h3&gt; &lt;time class=\"news-item-date\" datetime=\"2019-04-11T11:19:37\"&gt;2019.04.11&lt;/time&gt; &lt;p class=\"news-item-brief\"&gt;디자인 및 다양한 view 환경을 고려하여 구성되어 있으며, 기존보다 최신 정보 및 개발자를 위한 기술 가이드도 찾기 쉽도록 구성되어 있습니다. &lt;/p&gt; &lt;figure class=\"news-item-thumbnail\"&gt; &lt;img src=\"./images/news.gif\" alt=\"\"&gt; &lt;figcaption&gt;W3C 리뉴얼&lt;/figcaption&gt; &lt;/figure&gt; &lt;/a&gt; &lt;/article&gt; &lt;a href=\"#\" class=\"news-more icon-plus\" title=\"새소식\" target=\"_blank\"&gt;더보기&lt;/a&gt;&lt;/section&gt; css내 css123456789101112131415161718192021222324252627282930313233343536373839404142434445/* news */.news{ position: relative; }.news-heading{ padding: 15px 0; color: #e25d2d; font-weight: 700;}.news-item{ position: relative; margin: 35px 0;}.news-item-subject{ float: right; width: 245px; font-weight: 700;}.news-item-date{ float: right; width: 245px; margin-bottom: 10px;}.news-item-brief{ float: right; width: 245px;}.news-item-thumbnail{ float: left; position: absolute; top: 0; text-align: center;}.news-item-thumbnail&gt;figcaption{ margin-top: 10px;}.news&gt;a{ position: absolute; right: 0; top: 15px;}.news&gt;a::before{ color: darkgreen;} 강사님 css123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354.news{ margin-top: 20px; position: relative;}.news::before{ content: \"\"; position: absolute; top: 35px; left: 0; width: 80%; height: 1px; background: #aaa linear-gradient(to right, #aaa, #fff);}.news-heading{ font-size: 1.5rem; font-weight: 700; color:#e25d2d; }.news-item{ margin-top: 35px; position: relative;}.news-item a{ display: block; padding-left: 130px; }.news-item-subject{ font-size: 1.5rem;}.news-item-brief{ margin-top: 10px; line-height: 1.5;}.news-item-thumbnail{ position: absolute; top: 3px; left: 0; text-align: center; }.news-item-thumbnail img{ margin-bottom: 15px; box-shadow: 0 10px 15px 5px #aaa ;}.news-more{ position: absolute; padding: 8px; top: -8px; right: -8px;;}.news-more::before{ color: hsla(110, 90%, 30%, 1);} a tag에 여러 요소가 있을 때 a tag를 block으로 하면 선택 촛점 영역이 반듯해짐 이벤트 &amp; 사이트 마크업내 마크업1234567891011121314151617div section.event h2.event-heading span div.event-content p img.event-thumbnail p.event-brief div.event-buttons button.event-pre button.event-next section.relation h2.relation-heading span ul.relation-site-list li.relation-site-item a.relation-site-item-text IR123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html lang=\"ko_KR\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\" &lt;title&gt;IR 기법 및 Sprite 이미지의 활용&lt;/title&gt; &lt;style&gt; .btn-wrapper{ background: yellow; margin: 50px; } .btn-wrapper span{ background: pink; display: inline-block; width: 20px; height: 0; padding-top: 20px; overflow: hidden; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"btn-wrapper\"&gt; &lt;span class=\"btn-prev\"&gt;이전&lt;/span&gt; &lt;span class=\"btn-prev\"&gt;이전&lt;/span&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 1234567891011.btn-wrapper span{ background: pink url(\"./css/images/backpage_forwardpage.png\"); display: inline-block; width: 20px; height: 0; padding-top: 20px; overflow: hidden; } .btn-wrapper .btn-next{ background-position: -40px 0; } 12345678910111213.btn-wrapper span{ background-color: pink; background-image: url(\"./css/images/backpage_forwardpage.png\"); background-repeat: repeat; display: inline-block; width: 20px; height: 0; padding-top: 20px; overflow: hidden; } .btn-next{ background-position: -40px 0; } 위 css는 .btn-wrapper span의 background를 대표속성을 사용하여 background-position이 자동으로 지정됨 .btn-next의 선택자 우선순위가 더 낮아서 .btn-wrapper .btn-next로 선택해야 지정이 됨 아래 css는 대표속성을 사용하지 않아 .btn-next로 선택해도 동작 https://windtale.net/blog/css-image-sprite-automation-with-grunt-spritesmith/","link":"/2019/04/11/fc-190411/"},{"title":"2019-04-08 TIL","text":"시멘틱 마크업article.term h2.term-head div.term-body h3.term-title img.term-img span.term-content section.term h2.section-heading{웹 관련 용어} dl.term_list div dt.term-list-subject a dl.term-list-thumbnail img dd.term-list-brief text img&lt;img src=\"경로\" alt&gt; &lt;img src=\"경로\" alt=\"설명\"&gt; 대체 text가 없으면 장식으로 인식(위) inlinebase line 기준으로 아래 2px 정도의 descender발생 input1:1 label 필요, title=””을 이용하여 암묵적 label가능 ie 버전에 따라 main 및 기타 html5 추가 태그를 지원하지 않음html5 shiv","link":"/2019/04/08/fc-190408/"},{"title":"2019-04-15 TIL","text":"footerimg 마크업내 마크업1234567891011121314div.footer-bg footer.footer a img ul.footer-menu li div.copyright p a p div.badge img.badge-html img.badge-css 강사님 마크업123456789101112131415.footer a.footer-logo img ul.guide li a address.address span span span a small.copyright div.badge img img address주소, 연락처에 사용본문에서는 사용하지 않음 small &amp; bigsmall : 주변 보다 작게big : 주변 보다 크게 copyright&amp;copy\\; 로 입력 반응형paddingpadding 은 width의 값을 기준으로 동작width가 100% 일 때 padding-top을 75%로 하면 4:3이 됨","link":"/2019/04/15/fc-190415/"},{"title":"2019-04-12 TIL","text":"인기 사이트 마크업내 마크업1234567section.favorite h2.favorite-heading ol.favorite-list li a strong a.favorite-more 강사님 마크업1234567section.favorite h2.favorite=heading ol li.no1 a em.up, em.down, em.stop favorite-more 인용구 인용구 tag12&lt;q&gt;&lt;/q&gt;&lt;blockquote&gt;&lt;/blockquote&gt; 마크업 1234article.web-cafe h2 p footer article에 footer를 숨김영역으로 하여 내용을 복사 할 때 같이 복사가 됨 html123456789&lt;article class=\"slogan\"&gt; &lt;h2 class=\"slogan-heading\" title=\"웹카페에서 웹표준을\"&gt;슬로건&lt;/h2&gt; &lt;p class=\"slogan-content\"&gt; &lt;q site=\"http://w3.org\"&gt;The power of the Web is in its universality, Access by everyone regardless of disability is an essential aspect.\" Tim Berners - Lee , W3C Director and inventor of the World Wide Web&lt;/q&gt; &lt;footer class=\"readable-hidden\"&gt; 출처 : Worl Wide Web Consortium &lt;/footer&gt; &lt;/p&gt;&lt;/article&gt; 12345678910111213141516171819202122232425262728293031.slogan{ position: relative; padding:10px 70px 10px 180px;}.slogan-heading{ width: 110px; height: 83px; line-height: 83px; text-align: center; position: absolute; left: 35px; bottom: -35px;} .slogan-heading::after{ content: \"\"; width: 100%; height: 100%; position: absolute; top: 0; left: 0; background: url(\"./images/coffee.png\") no-repeat;}.slogan-content{ color: #a09784;}.slogan-content q::before{ content: '\"'; font-size: 3rem; position: relative; top:10px;}","link":"/2019/04/12/fc-190412/"},{"title":"2019-04-09 TIL","text":"timedatetime 필요time[datetime=”2019-04-09T11:18:27”] aria 이용한 title1234567891011121314151617181920212223242526&lt;section class=\"notice board-act\"&gt; &lt;h2 class=\"tab notice-heading\" tabindex=\"0\"&gt;공지사항&lt;/h2&gt; &lt;ul class=\"board-list notice-list\"&gt; &lt;li class=\"icon-dot-circled\"&gt; &lt;a href=\"#\"&gt;&lt;/a&gt; &lt;time datetime=\"2019-04-09T11:18:27\"&gt;2019.04.09&lt;/time&gt; &lt;/li&gt; &lt;li class=\"icon-dot-circled\"&gt; &lt;a href=\"#\"&gt;&lt;/a&gt; &lt;time datetime=\"2019-04-09T11:18:27\"&gt;2019.04.09&lt;/time&gt; &lt;/li&gt; &lt;li class=\"icon-dot-circled\"&gt; &lt;a href=\"#\"&gt;&lt;/a&gt; &lt;time datetime=\"2019-04-09T11:18:27\"&gt;2019.04.09&lt;/time&gt; &lt;/li&gt; &lt;li class=\"icon-dot-circled\"&gt; &lt;a href=\"#\"&gt;&lt;/a&gt; &lt;time datetime=\"2019-04-09T11:18:27\"&gt;2019.04.09&lt;/time&gt; &lt;/li&gt; &lt;li class=\"icon-dot-circled\"&gt; &lt;a href=\"#\"&gt;&lt;/a&gt; &lt;time datetime=\"2019-04-09T11:18:27\"&gt;2019.04.09&lt;/time&gt; &lt;/li&gt; &lt;/ul&gt; &lt;a href=\"#\" class=\"icon-plus board-more notice-more\" title=\"공지사항\" &gt;더보기&lt;/a&gt;&lt;/section&gt; 1234567891011121314151617181920212223242526&lt;section class=\"notice board-act\"&gt; &lt;h2 id=\"notice\" class=\"tab notice-heading\" tabindex=\"0\"&gt;공지사항&lt;/h2&gt; &lt;ul class=\"board-list notice-list\"&gt; &lt;li class=\"icon-dot-circled\"&gt; &lt;a href=\"#\"&gt;&lt;/a&gt; &lt;time datetime=\"2019-04-09T11:18:27\"&gt;2019.04.09&lt;/time&gt; &lt;/li&gt; &lt;li class=\"icon-dot-circled\"&gt; &lt;a href=\"#\"&gt;&lt;/a&gt; &lt;time datetime=\"2019-04-09T11:18:27\"&gt;2019.04.09&lt;/time&gt; &lt;/li&gt; &lt;li class=\"icon-dot-circled\"&gt; &lt;a href=\"#\"&gt;&lt;/a&gt; &lt;time datetime=\"2019-04-09T11:18:27\"&gt;2019.04.09&lt;/time&gt; &lt;/li&gt; &lt;li class=\"icon-dot-circled\"&gt; &lt;a href=\"#\"&gt;&lt;/a&gt; &lt;time datetime=\"2019-04-09T11:18:27\"&gt;2019.04.09&lt;/time&gt; &lt;/li&gt; &lt;li class=\"icon-dot-circled\"&gt; &lt;a href=\"#\"&gt;&lt;/a&gt; &lt;time datetime=\"2019-04-09T11:18:27\"&gt;2019.04.09&lt;/time&gt; &lt;/li&gt; &lt;/ul&gt; &lt;a href=\"#\" class=\"icon-plus board-more notice-more\" title=\"공지사항\" aria-labelledby=\"notice\"&gt;더보기&lt;/a&gt;&lt;/section&gt; javascritpdeferdefer 속성은 HTML 구문 분석이 완전히 완료되면 스크립트 파일을 실행하도록 브라우저에 지시","link":"/2019/04/09/fc-190409/"},{"title":"Javascript","text":"Data type Literal과 Expression Primitive type vs. Object type Function Definition Scope, Lexical Scope 전역 변수의 문제점과 var 키워드로 선언한 변수의 문제점 Constructor Function this DOM브라우저 동작[Event Delegation][Event Capturing vs. Event Bubbling][Class][super][Prototype][Promise][동기식 처리 모델 vs. 비동기식 처리 모델]","link":"/2019/06/03/javascript-keyword/"},{"title":"2019-04-16 TIL","text":"picture&lt;picture&gt; 내에 &lt;img&gt;를 사용하는 것은 필수 12345&lt;div class=\"rwd-wrapper\"&gt; &lt;picture&gt; &lt;source srcset=\"images/image-1x.png 1x, images/image-2x.png 2x\" &lt;/picture&gt;&lt;/div&gt; 123456&lt;div class=\"rwd-wrapper\"&gt; &lt;picture&gt; &lt;source srcset=\"images/image-1x.png 1x, images/image-2x.png 2x\"&gt; &lt;img src=\"images/image-src.png\"&gt; &lt;/picture&gt;&lt;/div&gt;","link":"/2019/04/16/fc-190416/"},{"title":"to-do list","text":"to-do list3주차 과제 javascript, jquery, bootstrap을 이용한 todo listlocalstorage를 이용한 save &amp; load Live Demo https://hicucu.github.io/javascript-basic/todo_v2_with_storage.html","link":"/2019/03/19/to-do-list/"},{"title":"javascript-sort","text":"Javascript Array sort기본오름차순123const array = ['z', 'c', 'a'];array.sort();console.log(array); 내림차순123const array = ['z', 'c', 'a'];array.sort().reverse();console.log(array); Number type문제1234const points = [1, 2, 10, 20, 100, 30];points.sort();console.log(points); .sort() 메소드는 배열요소를 문자로 인식문자로 ‘10’이 ‘2’보다 작기 때문에 오름차순으로 10이 2보다 앞에 위치하게 됨 숫자배열의 sort12points.sort((a, b) =&gt; { return a - b; });console.log(points); (a, b) =&gt; { return a-b } 함수를 .sort() 메소드 매개변수로 전달하여 숫자 타입의 배열을 오름차순으로 정렬 할 수 있음 (a, b) =&gt; { return a-b }를 (a, b) =&gt; { return b-a }로 변경하여 내림차순 구현 가능 Object 배열 sort1234567891011121314151617181920const javascript = [ { id: 3, value: 'Vue.js' }, { id: 1, value: 'vanilla' }, { id: 2, value: 'Nodejs' }];// 비교 함수function compare(key) { return function (a, b) { return a[key] &gt; b[key] ? 1 : (a[key] &lt; b[key] ? -1 : 0); };}// id를 기준으로 정렬javascript.sort(compare('id'));console.log(javascript);// value 기준으로 정렬javascript.sort(compare('value'));console.log(javascript); 프로퍼티 값이 문자열인 경우, - 산술 연산으로 비교하면 NaN이 발생 비교 연산을 이용","link":"/2019/05/20/javascript-sort/"},{"title":"shopping_spree","text":"web-basic-project 참여인원 : 3인 총 제작 기간 5일 1일차 : 아이디어 및 컨셉 회의2일차 : 기본 레이아웃 및 메인기능 구현3일차 : 서브기능 정리 및 레이아웃 수정4일차 : 서브기능 구현 및 디자인요소 추가5일차 : 벨리데이션 잔고 어때?각기다른 쇼핑몰 장바구니가 불편하다는 생각에서 출발했다.필요순으로 분류하고분류별로 한눈에 볼수있고간편하면 더 좋겠다고 생각하며지극히 주관적인 자신만의 위시리스트를 기획하게 되었다. 기본적인 기능은원하는 상품의 링크를 가져와 상품정보를 입력하면나에게 꼭 필요한 상품인지 4단계중 선택,추가하면그동안 추가된 상품들이 순차적으로 리스트업 된다.삭제와 수정이 가능하며,앞서 설정한 중요도별로 상품을 한눈에 모아서 볼수 있다. 만들면서 가장 중점을 둔 부분은 편리함이다.간단한 기능만큼 필요한때 쉽게 꺼내쓸수 있는 앱으로 만들고 싶었다.크롬브라우저의 extention 기능을 구현하여,웹사이트를 굳이 방문하지 않아도 되는 번거로움을 줄였다. Live Demo https://hicucu.github.io/web-basic-project/","link":"/2019/03/29/shopping-spree/"},{"title":"javascript-3","text":"원시 값과 객체의 비교원시 타입 vs 객체 타입원시타입 : immutable value객체타입 : mutable value원시 값을 변수에 할당하면 변수에는 실제 값이 저장객체를 변수에 할당하면 변수에 참조 값이 저장Pass by value : 원시 값을 갖는 변수를 다른 변수에 할당하면 원본의 원시 값이 복사Pass by referencce : 객체를 가리키는 변수를 다른 변수에 할당하면 원본의 참조 값이 복사 원시값변경 불가능한 값immutable value : 변경 불가능한 값, read only재할당과는 다른 의미원시 값을 갖는 변수에 다른 값을 넣으면 기존 메모리에 값이 변경되는 것이 아니라 새로운 메모리 공간을 확보하고 재할당한 원시 값을 저장변수가 참조하던 메모리 공간의 주소가 바뀜 문자열과 불변성문자열은 0개 이상인 문자(character)들의 집합한개의 문자는 2byte의 메모리 공간에 저장문자열 타입의 값은 몇개의 문자로 이루어졌는지에 따라 필요한 메모리 공간의 크기가 결정자바스크립트의 문자열은 원시타입으로 변경 불가능 유사배열배열은 아니지만 마치 배열처럼 처리가능, 문자열은 배열처럼 인덱스를 통해 각 문자에 접근할 수 있으며 for문으로 순회 가능, length 프로퍼티를 갖는 객체일 수 있음 값에 의한 전달할당한 변수가 원시 타입이라면 할당한 변수값이 복사되어 전달 -&gt; Pass by value변수를 다른 변수에 할당하면 두 변수의 값은 동일하지만 메모리 공간의 주소는 다름변수의 값을 변경해도 다른 변수의 값은 불변 객체프로퍼티의 개수가 정해져 있지 않으며 동적으로 추가, 삭제 가능프로퍼티의 값에도 제약이 없음원시 값과 같이 확보해야 할 메모리 공간의 크기를 사전에 정해 둘 수 없음 자바스크립트는 클래스 없이 객체를 생성할 수 있으며 생성 후 동적으로 프로퍼티와 메소드를 추가 할 수 있음 변경 가능한 값객체를 할당한 변수는 참조 값을 갖음 객체를 변경할 때 마다 원시 값처럼 이전 값을 복사하여 새롭게 생성한다면 명확하고 깔끔하지만 객체는 크기가 매우 클 수도 있고 프로퍼티 값이 객체일 수도 있어 복사하고 생성하는데 많은 비용 필요 원시 값처럼 객체 자체를 복사하여 다시 생성하는 것을 깊은 복사, 참조 값을 복하는 것을 얕은 복사라 함 객체는 여러 개의 식별자가 하나의 객체를 공유할 수 있음 참조에 의한 전달두 식별자가 하나의 객체를 공유원본 또는 사본 어떤 곳에서 객체를 변경하면 서로 영향을 받음 함수함수일련의 과정을 문(statement)들로 구현하고 코드 블록으로 감싸서 하나의 실행 단위로 정의한 것프로그래밍 언어의 함수도 입력을 받아서 출력매개변수(parameter) : 입력을 전달받는 변수인수(argument) : 입력반환값(return value) : 출력 함수가 여러개 존재 할 수 있으므로 특정 함수를 구별하기 위해 식별자인 함수명을 사용 함수는 함수 정의를 통해 생성함수 정의만으로 함수는 실행되지 않음미리 정의된 일련의 과정을 실행하기 위해 필요한 입력, 즉 인수를 매개변수를 통해 함수에게 전달하면서 함수의 실행을 지시해야 함 -&gt; 함수 호출 함수 호출을 하면 코드 블록에 담긴 문들이 일괄적으로 실행되고 결과를 반환 함수의 사용 이유필요할 때 여러 번 호출 가능동일 작업을 반복 수행할 때 같은 코드의 중복을 제거 -&gt; 코드의 재사용 유지보수의 편의성을 높이고 실수를 줄여 코드의 신뢰성을 높이는 효과 함수 리터럴객체는 객체 리터럴 표기법으로 생성함수도 함수 리터럴로 생성일반 객체는 호출 불가, 함수는 호출 가능 함수 리터럴은 function 키워드, 함수명, 매개변수 목록 그리고 함수 몸체로 구성 함수명 함수명은 식별자 -&gt; 네이밍 규칙 준수 몸체 내에서만 참조 가능 생략가능 -&gt; 익명함수 매개변수 목록 0개 이상 매개변수를 괄호로 감싸고 쉼표로 구분 매개변수에는 인수가 할당 함수 몸체 내에서 변수와 동일 취급 함수 몸체 함수가 호출되었을 때 일괄적으로 실행될 문들을 하나의 실행 단위로 정의한 코드 불록 함수 호출에 의해 실행 함수 vs 일반 객체함수는 객체일반 객체는 호출 불가함수는 고유한 프로퍼티 보유 함수 정의정의 방법 함수 선언문 함수 표현식 function 생성자 함수 화살표 함수 : ES6 함수 선언문함수 리터럴 표기법과 동일 형태함수명 생략 가능 함수명을 호출하는 것이 아니라 함수 객체를 가리키는 변수를 호출함수 선언문 방식으로 생성된 함수를 호출한 것은 함수명이 아니라 자바스크립트 엔진이 암묵적으로 생성한 변수함수명과 변수명이 일치하여 함수명으로 호출되는 듯 보이나 변수명으로 호출된 것 자바스크립트 엔진은 함수 선언문을 함수 표현식으로 변환하여 함수 객체를 생성한다 생각 할 수 있음 함수 표현식함수는 일급 객체이므로 함수 리터럴로 생성한 함수 객체를 변수에 할당가능 -&gt; 함수 표현식함수 표현식의 함수 리터럴은 함수명을 생략하는 것이 일반적 함수 선언문은 표현식이 아닌 문이고 함수 표현식은 표현식인 문 함수 선언문 vs 함수 표현식// 함수 선언문var add = function add(x, y) {return x + y;}; // 함수 표현식var add = function (x, y) {return x + y;}; 함수 생성 시점과 함수 호이스팅함수 선언문으로 정의한 함수와 함수 표현식으로 정의한 함수의 생성시점은 다름함수 선언문은 코드의 선두로 끌어 올려진 것처럼 동작 -&gt; 함수 호이스팅 함수 호이스팅 vs 변수 호이스팅변수 호이스팅은 선언 단계와 초기화 단계가 동시에 진행되며 다른 코드가 실행되기 이전에 수행함수 호이스팅은 선언 단계와 초기화 단계, 할당당계가 동시 진행 Function 생성자 함수생성자 함수 : 객체를 생성하는 함수, 객체를 생성하는 방식은 객체 리터럴 이외 다양한 방범이 존재 var add = new Function(‘x’, ‘y’, ‘return x + y’); Function 생성자 함수 방식으로 생성한 함수는 렉시컬 스코프를 만들지 않고 전역 함수인 것처럼 스코프를 생성클로저도 생성하지 않음 화살표 함수ES6에서 도입항상 익명 함수로 정의기존 함수와 this 바인딩 방식이 다르고 prototype 프로퍼티가 없고 arguments 객체를 생성하지 않음 함수 호출함수를 참조하는 변수와 한 쌍의 소괄호인 함수 호출 연산자로 호출0개 이상의 인수를 쉼표로 구분하여 나열인수는 매개변수에 할당할 수 있는 값 함수를 호출하면 현재 실행 흐름을 중단, 호출된 함수로 컨트롤 이관매개변수에 인수가 할당되고 함수 몸체의 문들이 실행 매개변수와 인수함수의 실행을 위해 함수 외부에서 함수 내부로 값을 전달할 필요가 있는 경우, 매개변수를 통해 인수를 전달함수를 호출할 때 지정하며 개수와 타입에 제한이 없음 함수를 호출할 때 매개변수의 개수만큼 인수를 전달하는 것이 일반적그렇지 않아도 에러가 발생하지는 않음함수는 매개변수의 개수와 인수의 개수를 체크하지 않음인수가 부족한 경우 매개변수의 값은 undefined 인수가 매개변수보다 만은 경우, 초과되는 인수는 무시-&gt; 암묵적으로 모든 인수는 arguments 객체의 프로퍼티로 보관 인수 확인자바스크립트 함수는 매개변수와 인수의 개수가 일치하는지 확인하지 않음동적타입 언어로 매개변수의 타입을 사전에 지정하지 않음-&gt; 적절한 인수가 전달되었는지 확인 필요 매개변수의 개수매개변수의 최대 개수 제한은 ECMAScript 스펙에 정해져 있지 않음-&gt; 브라우저마다 제각각 일반적으로 3개 이하 0개가 가장 이상적 외부 상태의 변경과 함수형 프로그래밍원시값 : 값에 의한 전달객체 : 참조에 의한 전달매개변수도 함수 몸체 내부에서 동일 취급 값에 의한 전달은 값이 복사되는 것으로 원본 보장참조에 의한 전달은 원본 훼손 발생 반환문함수는 return 키워드와 반환값으로 이루어진 반환문을 사용하여 실행 결과를 반환 반환문은 함수의 실행을 중단, 함수 몸체를 빠져나가는 역활과 return 키워드 뒤에 지정한 값을 반환 return 키워드 뒤에 반환값을 명시적으로 지정하지 않으면 undefined가 반환반환문을 생략하면 암묵적 undefined 반환 다양한 함수의 형태즉시실행함수함수의 정의와 동시에 즉시 호출 -&gt; IIFE한번만 호출되며 다시 호출 불가함수 선언문이나 함수 표현식을 그룹 연산자로 감싸면 함수가 평가되어 함수 객체가 됨 123456789101112131415(function() { // ...})();(function() { // ...})();!(function() { // ...})();+(function() { // ...})(); 모두 가능하지만 일반적으로 처음 방법을 사용 즉시 실행 함수 내에 코드를 모아두면 혹시 있을 수 있는 변수명 또는 함수명의 충돌을 방지 재귀 함수함수가 자기 자신을 호출하는 것반드시 탈출 조건이 필요 -&gt; 없을 경우 무한히 연쇄 호출 대부분 for문이나 while문으로 구현 가능-&gt; 재귀함수를 사용하는 것이 반복문을 사용하는 것보다 직관적으로 이해하기 쉬울 때에만 한정적 사용이 바람직 중첩 함수함수 내부에 정의된 함수일반적으로 자신을 포함한 외부함수를 돕는 헬퍼함수의 역활 콜백함수자바스크립트의 함수는 일급 객체로 함수의 인수로 함수 전달 가능콜백함수는 콜백 함수를 인수로 전달 받은 함수가 호출 시점을 결정하여 호출 콜백 함수가 콜백 함수를 전달받는 함수 내부에만 호출된다면 익명 함수 리터럴로 정의하면서 곧바로 전달하는 것이 일반적이때 콜백함수로서 전달된 함수 리터럴은 콜백 함수를 전달받은 함수가 호출될 때 평가되어 생성단, 콜백 함수를 다른 곳에서도 호출할 필요가 있거나, 콜백 함수를 전달 받는 함수가 자주 호출된다면 함수 외부에서 정의 후 변수를 전달하는 것이 효율적 중첩 함수가 외부 함수를 돕는 헬퍼 함수의 열활을 하는 것 처럼 콜백 함수는 함수에 전달되어 헬퍼 함수의 역활 수행중첩 함수는 고정되어 교체 불가, 콜백하뭇는 외부에서 인수로 주입하기 때문에 자유롭게 교체 가능 스코프유효범위식별자를 검색하는 규칙 스코프란?변수는 자신이 선언된 위치에 의해 자신이 유효한 범위, 즉 다른 코드가 변수 자신을 참조할 수 있는 범위가 결정 -&gt; 스코프(Scope, 유효범위) 스코프라는 개념이 없다면 전체 프로그램에서 동일 변수명은 사용이 불가 var 키워드로 선언된 변수는 같은 스코프 내에서 중복 선언이 허용 -&gt; 의도치 않게 변수 값이 변경되는 부작용 발생let, const 키워드로 선언된 변수는 같은 스코프내에서 중복 선언을 허용하지 않음 스코프의 종류전역 : 코드의 바깥 영역 -&gt; 전역 스코프, 전역 변수지역 : 함수 몸체 내부 -&gt; 지역 스코프, 지역 변수 전역과 전역 스코프전역이란 코드의 가장 바깥 영역전역은 전역 스코프를 생성전역에 변수를 선언하면 전역 스코프를 갖는 전역 변수가 됨전역 변수는 어지서든 참조 가능 지역과 지역 스코프지역이란 함수 몸체 내부지역 변수는 자신의 지역 스코프와 하위 지역 스코프에서 유효전역과 지역에 동일한 변수명이 있고 지역에서 해당 변수를 찾는 다면 지역에 선언된 변수를 참조 스코프 체인스코프는 함수의 중첩에 의해 계충적 구조를 갖음외부 함수의 지역 스코프를 중첩 함수의 상위 스코프라 함-&gt; 이렇게 스코프가 계층적으로 연결된 것을 스코프 체인이라 함 변수를 참조할 때, 자바스크립트 엔진은 스코프 체인을 통해 변수를 참조하는 코드의 스코프에서 시작하여 상위 스코프 방향으로 이동하며 선언된 변수를 검색 상위 스코프에서 유요한 변수는 하위 스코프에서 자유롭게 참조할 수 있지만 하위 스코프에서 유효한 변수를 상위 스코프에서 참조할 수 없음 함수를 어디서 호출했는지가 아닌 어디에 정의 했는가에 따라 상위 스코프를 결정 암묵적 전역 변수선언하지 않은 변수에 값을 할당하면 자바스크립트 엔진은 아무런 에러없이 암묵적으로 전역 변수를 선언하고 값을 할당 -&gt; 암묵적 전역 변수 자바스크립트는 파일마다 독립적인 파일 스코프를 갖지 않음-&gt; 하나의 전역","link":"/2019/05/09/javascript-3/"},{"title":"javascript-2","text":"제어문주어진 조건에 따라 블록을 실행하거나 반복 실행 할 때 사용일반적 코드의 실행 순서를 인위적으로 제어 블록문0개 이상의 문을 중괄호로 묶은 것자바스크립트에서는 하나의 실행 단위로 취급단독으로 사용가능하나 일반적으로 제어문, 함수 선언문 등에서 사용 조건문주어진 조건식의 평가 결과에 따라 코드 블록의 실행 결정조건식은 boolean 값으로 평가될 수 있는 표현 식 if…else 문주어진 조건식의 평과 결과에 따라 실행할 코드 블록을 결정조건식의 평가 결과가 불리언 값이 아니면 불리언으로 강제 변환되어 논리적 구별 else if, else는 옵션if와 else는 2번 사용 할 수 없지만 else if는 여러번 사용 가능 대부분 삼항 조건 연산자와 바꿔 사용 가능하지만 삼항 조건 연산자는 식으로 값처럼 사용이 가능하지만 if…else문은 값처럼 사용할 수 없는 문 switch 문주어진 표현식을 평가하여 그 값과 일치하는 표현식을 갖는 case문으로 실행 순서를 이동상황을 의미하는 표현식을 지정하고 콜론으로 마침switch 문의 표현식과 일치하는 case 문의 표현식이 없다면 default 문으로 이동 default 의 사용은 옵션 if…else vs switchif…else 문의 조건식은 반드시 불리언 값으로 평가switch 문의 표현식은 문자열, 숫자도 가능switch 문은 놀리적 참, 거짓 보다는 상황에 따라 실행할 코드 블록을 결정할 때 주 사용 반복문주어진 조건식의 평가 결과가 참인 경우 코드 블록을 실행실행 후 조건식을 다시 검사하여 여전히 참인 경우 다시 실행조건식이 거짓일 때까지 반복 for 문12for (변수 선언문 또는 할당문; 조건식; 증감식) 조건식이 참인 경우 반복 실행될 문; 변수 선언문, 조건식, 증감식은 모두 옵션어떤 식도 없으면 무한 루프 변수 선언문은 한 번만 실행코드 블록의 실행이 종료된 후 증감식이 실행조건식이 참이면 코드 블록 실행, 거짓이면 for 문의 실행 종료 while 문 vs do…while 문조건식의 평가 결과가 참이면 코드 블록을 계속해서 반복 실행조건식의 평가 결과가 불리언 값이 아니면 불리언 값으로 강제 변환되어 논리적 참, 거짓 구별 조건식의 평가 결과가 언제나 참이면 무한루프 do…while문은 코드 블록을 먼저 실행 후 조건식 평가 break 문코드 블록 탈출 -&gt; 레이블문, 반목문 또는 switch 문의 코드 블록을 탈출 레이블문, 반복문, switch 문의 코드 블록 이외에 break문을 사용하면 SyntaxError 레이블문 : 식별자가 붙은 문 // foo라는 레이블 식별자가 붙은 레이블 문foo: console.log(‘foo’); continue 문반복문의 코드 블록 실행을 현 시점에서 중단하고 반복문의 증감식으로 이동break 문처럼 반복문을 탈출하지 않음 타입 변환과 단축 평가타입 변환타입 캐스팅(Type casting) : 명시적 타입 변환(Explicit coercion), 개발자가 의도적으로 값의 타입을 변환한 것타입 강제 변환(Type coercion) : 암묵적 타입 변환(Implicit coercion), 개발자의 의도와 상관없이 자바스크립트 엔진에 의해 암묵적으로 타입이 자동 변환하는 것 암묵적 타입 변환자바스크립트 엔진은 표현식을 평가할 때 코드의 문맥을 고려하여 암묵적 타입 변환을 실행 자바스크립트는 가급적 에러를 발생시키지 않도록 암묵적 타입 변환을 통해 표현식을 평가 문자열 타입으로 변환문자열 연결 연산자 표현식을 평가하기 위해 문자열 연결 연산자의 피연산자 중에서 문자열 타입이 아닌 피연산자를 문자열 타입으로 암묵적 타입 변환 ex) 1 + ‘2’ //“12” 숫자 타입으로 변환산순 연산자의 역활은 숫자 값을 만드는 것, 따라서 산술 연산자의 모든 피연산자는 코드의 문맥 상 모두 숫자 타입이어야 함 ex)1 - ‘1’ // 0 1 * ‘10’ // 10 1 / ‘one’ // NaN 자바스크립트 엔진은 비교 연산자 표현식을 평가하기 위해 비교 연산자의 피연산자 중에서 숫자 타입이 아닌 피연산자를 숫자 타입으로 암묵적 타입 변환 ex)‘1’ &gt; 0 // true 불리언 타입으로 변환논리적 참, 거짓을 반환해야 하는 표현식에서 자바스크립트 엔진은 조건식의 평가 결과를 불리언 타입으로 암묵적 타입 변환 명시적 타입 변환 래퍼 객체 생성자 함수를 new 연산자 없이 호출하는 방법 빌트인 메소드를 사용하는 방법 암묵적 타입 변환을 이용하는 방법 문자열 타입으로 변환 console.log(String(1)); console.log((1).toString()); console.log(1 + ‘’) 숫자 타입으로 변환 console.log(Number(‘0’)); console.log(Number(true)); // 1 console.log(parseInt(‘0’)); // 0 console.log(+’0’); // 0 console.log(+true); // 1 console.log(‘0’ * 1); // 0 console.log(true * 1); // 1 불리언 타이으로 변환 boolean 생성자 함수를 new 연산자 없이 호출하는 방법 !부정 논리 연산자를 두번 사용하는 방법 단축 평가 단축 평가 표현식 평가 결과 true \\ \\ anything true false \\ \\ anything anything true &amp;&amp; anything anything false &amp;&amp; anything false 단축 평가 사용 패턴1234var elem = null;console.log(elem.value); // TypeError: Cannot read property 'value' of nullconsole.log(elem &amp;&amp; elem.value); // null 객체 리터럴객체란?javascript에서 원시 타입을 제외한 모든 것 원시 타입은 단 하나의 값만을 나타내지만 객체 타입(object / reference type)은 다양한 타입의 값(원시 타입의 값 또는 다른 객체)들을 하나의 단위로 구성한 복합적인 자료 구조 mutable value 키(key)와 값(value)로 구성된 프로퍼티(Property)의 집합 프로퍼티의 값은 자바스크립트에서 사용할 수 있는 모든 값 값으로 취급 가능 프로퍼티 값으로 함수를 사용할 수도 있으며 프로퍼티의 값이 함수일 경우 일반 함수와 구분하기 위해 메소드(Method)라고 부름 데이터를 의미하는 프로퍼티와 데이터를 참조하고 조작할 수 있는 동작을 의미하는 메소드로 구성데이터와 동작을 하나의 단위로 구조화 가능 자바스크립트는 함수로 객체를 생성하기도 하며 함수 자체가 객체 객체 리터럴에 의한 객체 생성인스턴스 : 클래스에 의해 생성되어 메모리에 저장된 실체객체 지향 프로그래밍에서 객체는 클래스와 인스턴스를 포함한 개념 자바스크립트의 객체 생성방법 객체 리터럴 : 가장 일반적이고 간단한 방법 Object 생성자 함수 생성자 함수 Object.create 메소드 클래스(ES6) 객체 리터럴의 중괄호는 코드 블록을 의미하지 않음객체 리터럴은 표현식 -&gt; 닫는 중괄호 뒤 ; 필요 객체를 생성하기 위해 클래스를 먼저 정의하고 new 연산자와 함께 생성자를 호출할 필요없음숫자 값이나 문자열 값을 만드는 것과 유사한 리터럴 표기법만드로 객체를 생성객체 리터럴에 프로퍼티를 포함시켜 객체의 생성과 동시에 프로퍼티를 만들 수 있고 객체를 생성한 후 프로퍼티를 동적으로 추가 가능 프로퍼티객체 = 프로퍼티의 집합프로퍼티 = 키와 값으로 구성프로퍼티의 나열은 ,로 구분마지막 프로퍼티의 ,은 없어도 됨 프로퍼티 키 빈 문자열을 포함하는 모든 문자열 symbol 값 프로퍼티 값에 접근할 수 있는 이름 식별자 네이밍규칙을 따라야 하지는 않음 숫자리터럴을 사용하면 암묵적 타입 변환을 통해 문자열로 변환 갱신 - 중복 선언시 나중에 선언한 프로퍼티가 덮어짐 -&gt; 에러 발생 안함 프로퍼티 값 자바스크립트에서 사용할 수 있는 모든 값 식별자 네이밍 규칙을 따르지 않는 이름에는 반드시 따옴표 필요 문자열 또는 문자열로 변환 가능한 값을 반환하는 표현식을 사용하여 프로퍼티 키 동적 생성 가능프로퍼티 키로 사용할 표현식을 [...]로 묶어야 함이를 계산된 프로퍼티 이름(Computed Property name)이라 함 빈 문자열을 프로퍼티 키로 사용해도 가능하지만 키로서 의미가 없으므로 권장하지 않음예약어도 사용 가능하지만 에러발생의 소지가 있어 권장하지 않음 메소드프로퍼티 값이 함수일 경우 일반 함수와 구분하기 위하여 메소드라 부름메소드 = 객체에 제한되어 있는 함수 this : 객체 자신을 가리키는 참조변수 프로퍼티 접근마침표 표기법(Dot notation), 대괄호 표기법(Bracket notation)으로 접근 네이밍 규칙을 따르는 이름으로 키를 만든 경우 두 방법 모두 사용 가능 -&gt; 네이밍 규칙을 따르지 않은 경우 반드시 대괄호 표기법을 사용해야 함 대괄호 연산자는 내부에 지정하는 프로퍼티 키는 반드시 따옴표를 감싼 문자열 -&gt; 없으면 식별자로 인식, 숫자의 경우 생략 가능 프로퍼티 동적 생성존재하지 않는 프로퍼티에 값을 할당하면 동적으로 생성되고 값이 할당 프로퍼티 삭제delete 연산자 이용delete 연산자의 피연산자는 프로퍼티 값에 접근할 수 있는 표현식 -&gt; 존재 하지 않는 프로퍼티의 삭제시 에러없이 무시 ES6에서 추가된 객체 리터럴 확장기능프로퍼티 축약 표현12345678// ES6let x = 1, y = 2;// 프로퍼티 축약 표현const obj = { x, y };console.log(obj); // {x: 1, y: 2} 변수명과 프로퍼티 키가 동일한 이름이면 프로퍼티 키 생략가능프로퍼티키가 변수의 이름으로 자동 생성 프로퍼티 키 동적 생성객체 리터럴 내부에서 프로퍼티 키 동적 생성 가능 메소드 축약 표현메소드 선언시 function 키워드 생략 가능 고찰 Truthy 값과 Falsy 값은 엔진에서 변환을 위해서만 존재하는건가요?해당 값들도 프로그래머가 사용 할 수 있나요?","link":"/2019/05/02/javascript-2/"}],"tags":[{"name":"Javascript","slug":"Javascript","link":"/tags/Javascript/"},{"name":"ESMAScript","slug":"ESMAScript","link":"/tags/ESMAScript/"},{"name":"aws","slug":"aws","link":"/tags/aws/"},{"name":"ec2","slug":"ec2","link":"/tags/ec2/"},{"name":"putty","slug":"putty","link":"/tags/putty/"},{"name":"express","slug":"express","link":"/tags/express/"},{"name":"HTML-CSS","slug":"HTML-CSS","link":"/tags/HTML-CSS/"},{"name":"study","slug":"study","link":"/tags/study/"},{"name":"coding","slug":"coding","link":"/tags/coding/"},{"name":"call by value","slug":"call-by-value","link":"/tags/call-by-value/"},{"name":"call by reference","slug":"call-by-reference","link":"/tags/call-by-reference/"},{"name":"JQuery","slug":"JQuery","link":"/tags/JQuery/"},{"name":"Bootstrap","slug":"Bootstrap","link":"/tags/Bootstrap/"},{"name":"Error","slug":"Error","link":"/tags/Error/"},{"name":"TypeError","slug":"TypeError","link":"/tags/TypeError/"},{"name":"codility","slug":"codility","link":"/tags/codility/"},{"name":"TIL","slug":"TIL","link":"/tags/TIL/"},{"name":"Data type","slug":"Data-type","link":"/tags/Data-type/"},{"name":"Literal","slug":"Literal","link":"/tags/Literal/"},{"name":"Expression","slug":"Expression","link":"/tags/Expression/"},{"name":"Primitive","slug":"Primitive","link":"/tags/Primitive/"},{"name":"Object","slug":"Object","link":"/tags/Object/"},{"name":"Function","slug":"Function","link":"/tags/Function/"},{"name":"Definition","slug":"Definition","link":"/tags/Definition/"},{"name":"Scope","slug":"Scope","link":"/tags/Scope/"},{"name":"Lexocal Scope","slug":"Lexocal-Scope","link":"/tags/Lexocal-Scope/"},{"name":"Global","slug":"Global","link":"/tags/Global/"},{"name":"var","slug":"var","link":"/tags/var/"},{"name":"Constructor","slug":"Constructor","link":"/tags/Constructor/"},{"name":"this","slug":"this","link":"/tags/this/"},{"name":"DOM","slug":"DOM","link":"/tags/DOM/"},{"name":"web-basic","slug":"web-basic","link":"/tags/web-basic/"},{"name":"homework","slug":"homework","link":"/tags/homework/"},{"name":"sort","slug":"sort","link":"/tags/sort/"},{"name":"project","slug":"project","link":"/tags/project/"},{"name":"mongodb","slug":"mongodb","link":"/tags/mongodb/"}],"categories":[{"name":"fast campus","slug":"fast-campus","link":"/categories/fast-campus/"},{"name":"aws","slug":"aws","link":"/categories/aws/"},{"name":"Javascript","slug":"fast-campus/Javascript","link":"/categories/fast-campus/Javascript/"},{"name":"Study","slug":"Study","link":"/categories/Study/"},{"name":"HTML-CSS","slug":"Study/HTML-CSS","link":"/categories/Study/HTML-CSS/"},{"name":"programming","slug":"Study/programming","link":"/categories/Study/programming/"},{"name":"Front-end","slug":"Study/Front-end","link":"/categories/Study/Front-end/"},{"name":"codility","slug":"codility","link":"/categories/codility/"},{"name":"HTML-CSS","slug":"fast-campus/HTML-CSS","link":"/categories/fast-campus/HTML-CSS/"},{"name":"web-basic","slug":"fast-campus/web-basic","link":"/categories/fast-campus/web-basic/"}]}